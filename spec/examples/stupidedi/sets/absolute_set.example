# encoding: UTF-8
require "spec_helper"

describe Stupidedi::Sets::AbsoluteSet do
  include QuickCheck::Macro

  def mksubset(universe)
    universe.copy(:mask => rand(2**universe.size))
  end

  def mksingleton(universe)
    universe.copy(:mask => (2**(rand(universe.size) + 1) >> 1))
  end

  let(:items) { %w(a b c d e f g h i j k l m n o p q r s t u v w x y z) }

  let(:universe) { Stupidedi::Sets.absolute(items) }
  let(:single)   { universe.copy(:mask => 0b00000000000000000000000001) }
  let(:subset)   { universe.copy(:mask => 0b10101010101010101010101010) }
  let(:null)     { universe.copy(:mask => 0b00000000000000000000000000) }

  describe "#to_a" do
  end

  describe "#map(&block)" do
    specify "A.map{|a| a } = A" do
      null.map{|a| a }.should == null
      single.map{|a| a }.should == single
      subset.map{|a| a }.should == subset
      universe.map{|a| a }.should == universe
    end

    property("A.map{|a| a } = A") do
      mksubset(universe)
    end.check do |subset|
      subset.map{|a| a }.should == subset
    end

    specify "A.map{|a| b } = ∅, given b ∉ U" do
      null.map{|a| "A" }.should == null
      single.map{|a| "A" }.should == null
      subset.map{|a| "A" }.should == null
      universe.map{|a| "A" }.should == null
    end

    property("A.map{|a| b } = ∅, given b ∉ U") do
      mksubset(universe)
    end.check do |subset|
      subset.map{|a| "A" }.should == null
    end

    specify "A.map{|a| b } = {b}, given b ∈ U, A ≠ ∅" do
      single.map{|a| "a" }.should == %w(a)
      subset.map{|a| subset.first }.should == [subset.first]
      universe.map{|a| "z" }.should == %w(z)
    end

    property("A.map{|a| b } = {b}, given b ∈ U, A ≠ ∅") do
      [mksubset(universe), choose(universe.to_a)]
    end.check do |subset, e|
      subset.map{|a| e }.should == [e]
    end
  end

  describe "#select(&block)" do
    specify "A.select{|a| true } = A" do
      null.select{|a| true }.should == null
      single.select{|a| true }.should == single
      subset.select{|a| true }.should == subset
      universe.select{|a| true }.should == universe
    end

    property("A.select{|a| true } = A") do
      mksubset(universe)
    end.check do |subset|
      subset.select{|a| true }.should == subset
    end

    specify "A.select{|a| false } = ∅" do
      null.select{|a| false }.should == null
      single.select{|a| false }.should == null
      subset.select{|a| false }.should == null
      universe.select{|a| false }.should == null
    end

    property("A.select{|a| false } = ∅") do
      mksubset(universe)
    end.check do |subset|
      subset.select{|a| false }.should == null
    end

    specify "A.select{|a| a == b } = {b}, given b ∈ U, A ≠ ∅" do
      single.select{|a| a == "a" }.should == %w(a)
      subset.select{|a| a == subset.first }.should == [subset.first]
      universe.select{|a| a == "a" }.should == %w(a)
    end

    property("A.select{|a| a == b } = {b}, given b ∈ U, A ≠ ∅") do
      subset  = mksubset(universe)
      element = choose(subset.to_a)
      [subset, element]
    end.check do |subset, e|
      subset.select{|a| a == e }.should == [e]
    end
  end

  describe "#include?(element)" do
    specify "x ∉ ∅, for all x" do
      null.include?("a").should be_false
      null.include?("A").should be_false
    end

    specify "x ∉ A, for all x ∉ U" do
      single.include?("A").should be_false
      subset.include?("A").should be_false
      universe.include?("A").should be_false
    end

    specify "a ∈ {a}, for all a" do
      single.include?("a").should be_true
    end

    property("a ∈ {a}, for all a") do
      mksingleton(universe)
    end.check do |singleton|
      singleton.include?(singleton.first).should be_true
    end

    property("x ∉ A, for all x ∈ ¬A") do
      mksubset(universe)
    end.check do |a|
      (~a).each{|e| a.include?(e).should_not be_true }
    end
  end

  describe "#finite?" do
    it "is true" do
      null.finite?.should be_true
      single.finite?.should be_true
      subset.finite?.should be_true
      universe.finite?.should be_true
    end
  end

  describe "#empty?" do
    specify "∅.empty? is true" do
      null.empty?.should be_true
    end

    specify "{a}.empty? is false" do
      single.empty?.should be_false
    end
  end

  describe "#size" do
    specify "∅.size == 0" do
      null.size == 0
    end

    specify "{a}.size == 1" do
      single.size.should == 1
    end
  end

  describe "#complement" do
    specify "A ∩ ¬A = ∅" do
      (null & ~null).should == null
      (single & ~single).should == null
      (subset & ~subset).should == null
      (universe & ~universe).should == null
    end

    property("A ∩ ¬A = ∅") do
      mksubset(universe)
    end.check do |a|
      (a & ~a).should == null
    end

    specify "A ∪ ¬A = U" do
      (null | ~null).should == universe
      (single | ~single).should == universe
      (subset | ~subset).should == universe
      (universe | ~universe).should == universe
    end

    property("A ∪ ¬A = U") do
      mksubset(universe)
    end.check do |a|
      (a | ~a).should == universe
    end

    specify "A ⊖ ¬A = U" do
      (null ^ ~null).should == universe
      (single ^ ~single).should == universe
      (subset ^ ~subset).should == universe
      (universe ^ ~universe).should == universe
    end

    property("A ⊖ ¬A = U") do
      mksubset(universe)
    end.check do |a|
      (a ^ ~a).should == universe
    end

    specify "A ∖ ¬A = A" do
      (null - ~null).should == null
      (single - ~single).should == single
      (subset - ~subset).should == subset
      (universe - ~universe).should == universe
    end

    property("A ∖ ¬A = A") do
      mksubset(universe)
    end.check do |a|
      (a - ~a).should == a
    end

    specify "x ∉ ¬A, for all x ∉ U" do
      (~null).include?("A").should be_false
      (~single).include?("A").should be_false
      (~subset).include?("A").should be_false
      (~universe).include?("A").should be_false
    end

    property("x ∈ ¬A, for all x ∈ U and x ∉ A") do
      mksubset(universe)
    end.check do |a|
      (~a).each{|e| a.include?(e).should be_false }
    end

    property("x ∉ ¬A, for all x ∈ U and x ∈ A") do
      mksubset(universe)
    end.check do |a|
      a.each{|e| (~a).include?(e).should be_false }
    end

    specify "¬U = ∅" do
      (~universe).should == null
    end

    specify "¬∅ = U" do
      (~null).should == universe
    end

    # Identity
    specify "¬(¬A) = A" do
      (~(~null)).should == null
      (~(~single)).should == single
      (~(~subset)).should == subset
      (~(~universe)).should == universe
    end

    property("¬(¬A) = A") do
      mksubset(universe)
    end.check do |a|
      (~(~a)).should == a
    end

    # De Morgan's Laws
    property("¬(A ∪ B) = ¬A ∩ ¬B") do
      [mksubset(universe), mksubset(universe)]
    end.check do |a, b|
      (~(a | b)).should == (~a & ~b)
    end

    property("¬(A ∩ B) = ¬A ∪ ¬B") do
      [mksubset(universe), mksubset(universe)]
    end.check do |a, b|
      (~(a & b)).should == (~a | ~b)
    end

    # Uniqueness of Complements
    property("B = ¬A, given A ∪ B = U and A ∩ B = ∅") do
      # Create a smaller universe, because the chances of choosing
      # two random subsets from 2**26 possible, that happen to be
      # complements of each other is very small.
      universe = Stupidedi::Sets.absolute(%w(a b c d e f))

      a = mksubset(universe)
      b = mksubset(universe)

      guard(a | b == universe)
      guard(a & b == null)

      [a, b]
    end.check(2, 500) do |a, b|
      b.should == ~a
    end
  end

  describe "#union(other)" do
    property("x ∈ A ∪ B, for all x ∈ A") do
      a = mksubset(universe)
      b = mksubset(universe)
      [a, b, (a | b)]
    end.check do |a, b, union|
      a.each{|x| union.include?(x).should be_true }
    end

    property("x ∈ A ∪ B, for all x ∈ B") do
      a = mksubset(universe)
      b = mksubset(universe)
      [a, b, (a | b)]
    end.check do |a, b, union|
      b.each{|x| union.include?(x).should be_true }
    end

    property("x ∉ A ∪ B, for all x ∉ A and x ∉ B") do
      a = mksubset(universe)
      b = mksubset(universe)
      [a, b, (a | b)]
    end.check do |a, b, union|
      universe.each do |x|
        unless a.include?(x) or b.include?(x)
          union.include?(x).should be_false
        end
      end
    end

    property("A ∪ B = A, given B ⊂ A") do
      # Create a smaller universe, because the chances of choosing
      # two random subsets from 2**26 possible, that happen to be
      # subsets of each other is very small.
      universe = Stupidedi::Sets.absolute(%w(a b c d e f))

      a = mksubset(universe)
      b = mksubset(universe)
      guard(b < a)

      [a, b]
    end.check do |a, b|
      (a | b).should == a
    end

    property("A ∪ B = B, given B ⊃ A") do
      # Create a smaller universe, because the chances of choosing
      # two random subsets from 2**26 possible, that happen to be
      # subsets of each other is very small.
      universe = Stupidedi::Sets.absolute(%w(a b c d e f))

      a = mksubset(universe)
      b = mksubset(universe)
      guard(b > a)

      [a, b]
    end.check do |a, b|
      (a | b).should == b
    end

    property("A ∪ B ⊇ A") do
      [mksubset(universe), mksubset(universe)]
    end.check do |a, b|
      (a | b).should >= a
    end

    property("A ∪ B ⊇ B") do
      [mksubset(universe), mksubset(universe)]
    end.check do |a, b|
      (a | b).should >= b
    end

    property("A ∪ B ⊃ A, given A ∩ B = ∅") do
      # Create a smaller universe, because the chances of choosing
      # two random subsets from 2**26 possible, that happen to be
      # subsets of each other is very small.
      universe = Stupidedi::Sets.absolute(%w(a b c d e f))

      a = mksubset(universe)
      b = mksubset(universe)
      guard(b & a == null)

      [a, b]
    end.check do |a, b|
      (a | b) > a
    end

    # Absorption
    property("A ∪ (A ∩ B) = A") do
      [mksubset(universe), mksubset(universe)]
    end.check do |a, b|
      (a | (a & b)).should == a
    end

    # Idempotent
    specify "A ∪ A = A" do
      (null + null).should == null
      (single + single).should == single
      (subset + subset).should == subset
      (universe + universe).should == universe
    end

    # Domination
    specify "A ∪ U = U" do
      (null + universe).should == universe
      (single + universe).should == universe
      (subset + universe).should == universe
      (universe + universe).should == universe
    end

    # Complement
    specify "A ∪ ¬A = U" do
      (null | ~null).should == universe
      (single | ~single).should == universe
      (subset | ~subset).should == universe
      (universe | ~universe).should == universe
    end

    # Identity
    specify "A ∪ ∅ = A" do
      (null + null).should == null
      (single + null).should == single
      (subset + null).should == subset
      (universe + null).should == universe
    end

    # Distributive
    property("A ∪ (B ∩ C) = (A ∪ B) ∩ (A ∪ C)") do
      [mksubset(universe), mksubset(universe), mksubset(universe)]
    end.check do |a, b, c|
      (a | (b & c)).should == ((a | b) & (a | c))
    end

    # Commutative
    property("A ∪ B = B ∪ A") do
      [mksubset(universe), mksubset(universe)]
    end.check do |a, b|
      (a | b).should == (b | a)
    end

    # Associative
    property("(A ∪ B) ∪ C = A ∪ (B ∪ C)") do
      [mksubset(universe), mksubset(universe), mksubset(universe)]
    end.check do |a, b, c|
      ((a | b) | c).should == (a | (b | c))
    end
  end

  describe "#intersection(other)" do
    specify "x ∈ A ∩ B, for all x ∈ A and x ∈ B"
    specify "x ∉ A ∩ B, for all x ∉ A"
    specify "x ∉ A ∩ B, for all x ∉ B"

    specify "A ∩ U = A" do
      (null & universe).should == null
      (single & universe).should == single
      (subset & universe).should == subset
      (universe & universe).should == universe
    end

    property("A ∩ B = A, given B ⊇ A") do
      # Create a smaller universe, because the chances of choosing
      # two random subsets from 2**26 possible, that happen to be
      # subsets of each other is very small.
      universe = Stupidedi::Sets.absolute(%w(a b c d e f))

      a = mksubset(universe)
      b = mksubset(universe)
      guard(b >= a)

      [a, b]
    end.check do |a, b|
      (a & b).should == a
    end

    property("A ∩ B = B, given B ⊆ A") do
      # Create a smaller universe, because the chances of choosing
      # two random subsets from 2**26 possible, that happen to be
      # subsets of each other is very small.
      universe = Stupidedi::Sets.absolute(%w(a b c d e f))

      a = mksubset(universe)
      b = mksubset(universe)
      guard(b <= a)

      [a, b]
    end.check do |a, b|
      (a & b).should == b
    end

    # Absorption
    property("A ∩ (A ∪ B) = A") do
      [mksubset(universe), mksubset(universe)]
    end.check do |a, b|
      (a & (a | b)).should == a
    end

    # Idempotent
    specify "A ∩ A = A" do
      (null & null).should == null
      (single & single).should == single
      (subset & subset).should == subset
      (universe & universe).should == universe
    end

    # Domination
    specify "A ∩ ∅ = ∅" do
      (null & null).should == null
      (single & null).should == null
      (subset & null).should == null
      (universe & null).should == null
    end

    # Complement
    specify "A ∩ ¬A = ∅" do
      (null & ~null).should == null
      (single & ~single).should == null
      (subset & ~subset).should == null
      (universe & ~universe).should == null
    end

    # Distributive
    property("A ∩ (B ∪ C) = (A ∩ B) ∪ (A ∩ C)") do
      [mksubset(universe), mksubset(universe), mksubset(universe)]
    end.check do |a, b, c|
      (a & (b | c)).should == ((a & b) | (a & c))
    end

    # Commutative
    property("A ∩ B = B ∩ A") do
      [mksubset(universe), mksubset(universe)]
    end.check do |a, b|
      (a & b).should == (b & a)
    end

    # Associative
    property("(A ∩ B) ∩ C = A ∩ (B ∩ C)") do
      [mksubset(universe), mksubset(universe), mksubset(universe)]
    end.check do |a, b, c|
      ((a & b) & c).should == (a & (b & c))
    end
  end

  describe "#difference(other)" do
    specify "x ∈ A ∖ B, for all x ∈ A and x ∉ B"
    specify "x ∉ A ∖ B, for all x ∉ A"
    specify "x ∉ A ∖ B, for all x ∈ B"

    specify "U ∖ A = ¬A" do
      (universe - null).should == ~null
      (universe - single).should == ~single
      (universe - subset).should == ~subset
      (universe - universe).should == ~universe
    end

    specify "∅ ∖ A = ∅" do
      (null - null).should == null
      (null - single).should == null
      (null - subset).should == null
      (null - universe).should == null
    end

    specify "A ∖ A = ∅" do
      (null - null).should == null
      (single - single).should == null
      (subset - subset).should == null
      (universe - universe).should == null
    end

    specify "A ∖ ∅ = A" do
      (null - null).should == null
      (single - null).should == single
      (subset - null).should == subset
      (universe - null).should == universe
    end

    specify "A ∖ U = ∅" do
      (null - universe).should == null
      (single - universe).should == null
      (subset - universe).should == null
      (universe - universe).should == null
    end

    property("A ∖ B = A, given A ∩ B = ∅")

    property("A ∖ B ⊂ A, given A ∩ B ≠ ∅") do
      a = mksubset(universe)
      b = mksubset(universe)
      guard(a & b != null)

      [a, b]
    end.check do |a, b|
      (a - b).should < a
    end

    property("A ∖ B ≠ B ∖ A, given A ≠ B") do
      a = mksubset(universe)
      b = mksubset(universe)
      guard(a != b)

      [a, b]
    end.check do |a, b|
      (a - b).should_not == (b - a)
    end

    property("C ∖ (A ∩ B) = (C ∖ A) ∪ (C ∖ B)") do
      [mksubset(universe), mksubset(universe), mksubset(universe)]
    end.check do |a, b, c|
      (c - (a & b)).should == ((c - a) | (c - b))
    end

    property("C ∖ (A ∪ B) = (C ∖ A) ∩ (C ∖ B)") do
      [mksubset(universe), mksubset(universe), mksubset(universe)]
    end.check do |a, b, c|
      (c - (a | b)).should == ((c - a) & (c - b))
    end

    property("C ∖ (B ∖ A) = (A ∩ C) ∪ (C ∖ B)") do
      [mksubset(universe), mksubset(universe), mksubset(universe)]
    end.check do |a, b, c|
      (c - (b - a)).should == ((a & c) | (c - b))
    end

  # property("(B ∖ A) ∩ C = (B ∩ C) ∖ A = B ∩ (C ∖ A)") do
  #   [mksubset(universe), mksubset(universe), mksubset(universe)]
  # end.check do |a, b, c|
  # end

    property("(B ∖ A) ∪ C = (B ∪ C) ∖ (A ∖ C)") do
      [mksubset(universe), mksubset(universe), mksubset(universe)]
    end.check do |a, b, c|
      ((b - a) | c).should == ((b | c) - (a - c))
    end

    property("B ∖ A = ¬A ∩ B") do
      [mksubset(universe), mksubset(universe)]
    end.check do |a, b|
      (b - a).should == (~a & b)
    end

    property("¬(B ∖ A) = A ∪ ¬B") do
      [mksubset(universe), mksubset(universe)]
    end.check do |a, b|
      (~(b - a)).should == (a | ~b)
    end
  end

  describe "#symmetric_difference(other)" do
    specify "A ⊖ A = ∅" do
      (null ^ null).should == null
      (single ^ single).should == null
      (subset ^ subset).should == null
      (universe ^ universe).should == null
    end

    # todo: check this property
    specify "A ⊖ U = ∅" do
    # (universe ^ universe).should == null
    # (null ^ universe).should == null
    # (single ^ universe).should == null
    # (subset ^ universe).should == null
    end

    specify "A ⊖ ∅ = A" do
      (null ^ null).should == null
      (single ^ null).should == single
      (subset ^ null).should == subset
      (universe ^ null).should == universe
    end

    property("A ⊖ B = (A ∖ B) ∪ (B ∖ A)") do
      [mksubset(universe), mksubset(universe)]
    end.check do |a, b|
      (a ^ b).should == ((a - b) | (b - a))
    end

    property("A ⊖ B = (A ∪ B) ∖ (A ∩ B)") do
      [mksubset(universe), mksubset(universe)]
    end.check do |a, b|
      (a ^ b).should == ((a | b) - (a & b))
    end

    property("A ⊖ B = B ⊖ A") do
      [mksubset(universe), mksubset(universe)]
    end.check do |a, b|
      (a ^ b).should == (b ^ a)
    end

    property("(A ⊖ B) ⊖ C = A ⊖ (B ⊖ C)") do
      [mksubset(universe), mksubset(universe), mksubset(universe)]
    end.check do |a, b, c|
      ((a ^ b) ^ c).should == (a ^ (b ^ c))
    end

    property("(A ⊖ B) ⊖ (B ⊖ C) = A ⊖ C") do
      [mksubset(universe), mksubset(universe), mksubset(universe)]
    end.check do |a, b, c|
      ((a ^ b) ^ (b ^ c)).should == (a ^ c)
    end

    property("A ∩ (B ⊖ C) = (A ∩ B) ⊖ (A ∩ C)") do
      [mksubset(universe), mksubset(universe), mksubset(universe)]
    end.check do |a, b, c|
      (a & (b ^ c)).should == ((a & b) ^ (a & c))
    end
  end

  describe "#subset?(other)" do
    # Reflexivity
    specify "A ⊆ A" do
      null.should <= null
      single.should <= single
      subset.should <= subset
      universe.should <= universe
    end

    # Antisymmetry
    specify "A ⊆ B and B ⊆ A, given A = B"
    specify "A = B, given A ⊆ B and B ⊆ A"

    # Transitivity
    specify "A ⊆ B, given A ⊆ B and B ⊆ C"

    # Existence of a Least Element
    specify "∅ ⊆ A" do
      null.should <= null
      null.should <= single
      null.should <= subset
      null.should <= universe
    end

    # Existence of a Greatest Element
    specify "A ⊆ U" do
      null.should <= universe
      single.should <= universe
      subset.should <= universe
      universe.should <= universe
    end

    # Existence of Joins
    specify "A ⊆ A ∪ B"
    specify "A ∪ B ⊆ C, given C ⊆ A and C ⊆ B"

    # Equivalent Statements
    specify "A ⊆ B"
    specify "A ∩ B = A"
    specify "A ∪ B = B"
    specify "A ∖ B = ∅"
    specify "¬B ⊆ ¬A"
  end

  describe "#==(other)" do
    # Reflexive
    specify "A = A" do
      null.should == null
      single.should == single
      subset.should == subset
      universe.should == universe
    end

    # Symmetric
    specify "if A = B then B = A"

    # Transitive
    specify "if A = B and B = C then A = C"
  end

  describe "#replace(other)" do
  end

end
