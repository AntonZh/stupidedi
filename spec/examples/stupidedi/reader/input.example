require "spec_helper"

describe Stupidedi::Reader::Input do
  include QuickCheck::Macro

  def input(*args)
    Stupidedi::Reader::Input.build(*args)
  end

  describe "#offset" do
    it "returns the value given to the constructor" do
      input("", 10, 20, 30).offset.should == 10
    end
  end

  describe "#line" do
    it "returns the value given to the constructor" do
      input("", 10, 20, 30).line.should == 20
    end
  end

  describe "#column" do
    it "returns the value given to the constructor" do
      input("", 10, 20, 30).column.should == 30
    end
  end

  describe "#defined_at?(n)" do
    context "when n is less than input length" do
      it "is true", :random => true do
        property do
          with(:size, between(1, 25)) { [string, between(0, size - 1)] }
        end.check do |s, n|
          input(s).defined_at?(n).should be_true
        end
      end
    end

    context "when n is equal to input length" do
      it "is false", :random => true do
        property do
          with(:size, between(0, 25)) { [string, size] }
        end.check do |s, n|
          input(s).defined_at?(n).should be_false
        end
      end
    end

    context "when n is greater than input length" do
      it "is false", :random => true do
        property do
          with(:size, between(0, 25)) { [string, size + integer.abs] }
        end.check do |s, n|
          input(s).defined_at?(n).should be_false
        end
      end
    end
  end

  describe "#empty?" do
    it "when the input is empty" do
      input("").should be_empty
      input([]).should be_empty
    end
  end

  describe "#drop(n)" do
    context "when n is zero" do
      it "returns itself" do
        input("abc").drop(0).should == "abc"
      end
    end

    context "when n is negative" do
      it "raises an error" do
        lambda { input("abc").drop(-1) }.should raise_error
      end
    end

    context "when less than n elements are available" do
      it "updates the input offset" do
        input("abc", 10).drop(25).offset.should == 13
      end

      it "updates the input offset", :random => true do
        property do
          with(:size, between(0, 25)) do
            [string, between(size + 1, 1000), between(10, 1000)]
          end
        end.check do |s, n, offset|
          input(s, offset).drop(n).offset.should == offset + s.length
        end
      end

      it "returns an empty input" do
        input("abc", 10).drop(10).should be_empty
      end
    end

    context "when n elements are available" do
      it "updates the input offset" do
        input("abc", 10).drop(2).offset.should == 12
      end

      it "updates the input offset", :random => true do
        property do
          with(:size, between(0, 25)) do
            [string, between(0, size), between(10, 1000)]
          end
        end.check do |s, n, offset|
          input(s, offset).drop(n).offset.should == offset + n
        end
      end

      it "returns an input with the first n elements removed" do
        input(%w(a b c d)).drop(3).should == %w(d)
      end

      it "returns an input with the first n elements removed", :random => true do
        property do
          with(:size, between(0, 25)) do
            [string, between(0, size)]
          end
        end.check do |s, n|
          input(s).drop(n).should == s.slice(n..-1)
        end
      end
    end
  end

  describe "#take(n)" do
    context "when n is zero" do
      it "returns an empty value" do
        input("abc").take(0).should == ""
      end

      it "returns an empty value" do
        input(%w(a b c)).take(0).should == []
      end
    end

    context "when n is negative" do
      it "raises an error" do
        lambda { input("abc").take(-1) }.should raise_error
      end
    end

    context "when less than n elements are available" do
      it "returns all available elements" do
        input("ab").take(3).should == "ab"
      end

      it "returns all available elements" do
        input(%w(a b)).take(3).should == %w(a b)
      end

      it "does not update the input offset" do
        input("abc", 500).tap do |x|
          x.take(4)
        end.offset.should == 500
      end
    end

    context "when n elements are available" do
      it "returns the first n elements" do
        input("abc").take(2).should == "ab"
      end

      it "returns the first n elements" do
        input(%w(a b c)).take(2).should == %w(a b)
      end

      it "does not update the input offset" do
        input("abc", 500).tap do |x|
          x.take(2)
        end.offset.should == 500
      end
    end
  end

  describe "#at(n)" do
    context "when n is negative" do
      it "raises an error" do
        lambda { input("abc").at(-1) }.should raise_error
      end
    end

    context "when the input is defined_at?(n)" do
      it "returns the element at index n" do
        input("abc").at(2).should == "c"
      end

      it "returns the element at index n" do
        input(%w(a b c)).at(2).should == "c"
      end

      it "does not update the input offset" do
        input("abc", 500).tap do |x|
          x.at(5)
        end.offset.should == 500
      end
    end

    context "when the input is not defined_at?(n)" do
      it "returns nil" do
        input("abc").at(3).should be_nil
      end

      it "returns nil" do
        input(%w(a b c)).at(3).should be_nil
      end

      it "does not update the input offset" do
        input("abc", 500).tap do |x|
          x.at(1)
        end.offset.should == 500
      end
    end
  end

  describe "#index(search)" do
    context "when search is an element in the input" do
      it "returns the smallest index" do
        input("abcabc").index("b").should == 1
        input(%w(a b c a b c)).index("b").should == 1
      end
    end

    context "when search is not an element in the input" do
      it "returns nil" do
        input("abc").index("d").should be_nil
        input(%w(a b c)).index("d").should be_nil
      end
    end
  end

end
