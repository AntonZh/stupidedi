require "spec_helper"

describe Stupidedi::Reader::DefaultReader do
  include QuickCheck::SerializedEdi::Macro

  def mkreader(input, isa = Stupidedi::Interchange::FiveOhOne::InterchangeHeader.default)
    Stupidedi::Reader::DefaultReader.new(input, isa)
  end

  describe ".from_reader" do
    it "copies reader#input and reader#interchange_header" do
      input  = mock("input")
      isa    = mock("interchange_header")
      reader = mock("reader", :input => input, :interchange_header => isa)

      default = Stupidedi::Reader::DefaultReader.from_reader(reader)
      default.input.should eq(input)
      default.interchange_header.should eq(isa)
    end
  end

  describe "#default" do
    let(:reader) { mkreader "" }

    it "should return itself" do
      reader.default.should eq(reader)
    end
  end

  describe "#input" do
    it "should return the argument given to its constructor" do
      property { string }.check{|s| mkreader(s).input.should eq(s) }
    end
  end

  describe "#interchange_header" do
    let(:isa) { Stupidedi::Interchange::FiveOhOne::InterchangeHeader.default }

    it "should return the argument given to its constructor" do
      mkreader("", isa).interchange_header.should eq(isa)
    end
  end

  describe "#empty?" do
    context "when input is an empty string" do
      it "returns true" do
        mkreader("").should be_empty
      end
    end

    context "when input is a non-empty string" do
      it "returns false" do
        mkreader(" ").should_not be_empty
      end

      it "returns false" do
        mkreader("x").should_not be_empty
      end
    end
  end

  describe "#consume_prefix" do
    context "when search string is a prefix of the input" do
      it "is defined" do
        mkreader("abc").consume_prefix("ab").should be_defined
      end

      it "is defined", :random => true do
        property do
          string.bind{|s| [stream.agitate(s), s.take(between(1, s.length - 1))] }
        end.check do |input, prefix|
          mkreader(input).consume_prefix(prefix).should be_defined
        end
      end

      it "consumes the search string" do
        mkreader("abc").consume_prefix("ab").
          map{|remainder| remainder.input.should == "c" }
      end

      it "consumes the search string", :random => true do
        property do
          with(:size, between(1, 25)) do
            # Generate an input string (s), and split it at a random position to get prefix and suffix
            string.bind{|s| [stream.agitate(s), *s.split_at(between(0, s.length - 1))] }
          end
        end.check do |input, prefix, suffix|
          mkreader(input).consume_prefix(prefix).
            map{|remainder| Stupidedi::Reader.strip(remainder.input).should == suffix }
        end
      end

      it "updates the input offset"
    end

    context "when the search string and input are equal" do
      it "is defined" do
        mkreader("abc").consume_prefix("abc").should be_defined
      end

      it "is defined", :random => true do
        property do
          with(:size, between(0, 25)) { string.bind{|s| [stream.agitate(s), s] }}
        end.check do |input, prefix|
          mkreader(input).consume_prefix(prefix).should be_defined
        end
      end

      it "consumes all input" do
        mkreader("abc").consume_prefix("abc").
          map{|remainder| remainder.should be_empty }
      end

      it "consumes all input", :random => true do
        property do
          with(:size, between(0, 25)) { string.bind{|s| [stream.agitate(s), s] }}
        end.check do |input, prefix|
          mkreader(input).consume_prefix(prefix).
            map{|remainder| Stupidedi::Reader.strip(remainder.input).should be_empty }
        end
      end

      it "updates the input offset"
    end

    context "when the search string is not a prefix of the input" do
      it "is not defined" do
        mkreader("abc").consume_prefix("abd").should_not be_defined
      end

      it "is not defined", :random => true do
        property do
          with(:size, between(1, 25)) do
            # Generate an input string (s), and the search string is that with one character altered
            string.bind{|s| [stream.agitate(s), s.succ] }
          end
        end.check do |input, search|
          mkreader(input).consume_prefix(search).should_not be_defined
        end
      end

      it "produces an error message" do
        mkreader("abc").consume_prefix("abd").
          explanation.should == %[Found "abc" instead of "abd"]
      end

      it "encodes the error position"
    end

    context "when the input is a suffix of the search string" do
      it "is not defined" do
        mkreader("bc").consume_prefix("abc").should_not be_defined
      end

      it "produces an error message" do
        mkreader("bc").consume_prefix("abc").
          explanation.should == %[Reached end of input without finding "abc"]
      end

      it "is not defined", :random => true do
        property do
          with(:size, between(1, 25)) do
            # Generate a search string (s), then the input is some suffix of that
            string.bind{|s| [stream.agitate(s.drop(between(1, s.length))), s] }
          end
        end.check do |input, search|
          mkreader(input).consume_prefix(search).should_not be_defined
        end
      end

      it "encodes the error position"
    end

    context "when the input is a prefix of the search string" do
      it "is not defined" do
        mkreader("ab").consume_prefix("abc").should_not be_defined
      end

      it "produces an error message" do
        mkreader("ab").consume_prefix("abc").
          explanation.should == %[Reached end of input without finding "abc"]
      end

      it "is not defined", :random => true do
        property do
          with(:size, between(1, 25)) do
            # Generate a search string (s), then the input is some prefix of that
            string.bind{|s| [stream.agitate(s.take(between(0, s.length - 1))), s] }
          end
        end.check do |input, search|
          mkreader(input).consume_prefix(search).should_not be_defined
        end
      end

      it "encodes the error position"
    end

    context "when the search string is empty" do
      it "is defined" do
        mkreader("abc").consume_prefix("").should be_defined
      end

      it "returns itself wrapped as a Either.success" do
        reader = mkreader("abc")
        reader.consume_prefix("").
          map{|remainder| remainder.should eq(reader) }
      end

      it "does not update the input offset"
    end
  end

  describe "#consume" do
    context "when input contains the search string" do
      it "is defined"

      it "updates the input offset"

      it "consumes input up to and including the search string"
    end

    context "when input does not contain the search string" do
      it "is not defined"

      it "produces an error message"

      it "encodes the error position"
    end
  end

  describe "#read_delimiter" do
    pending
  end

  describe "#read_element" do
    pending
  end

  describe "#read_segment_id" do
    pending
  end

  describe "#consume_interchange" do
    pending
  end

end
