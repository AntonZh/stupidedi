require "spec_helper"


describe Stupidedi::Reader::DefaultReader do
  include QuickCheck::SerializedEdi::Macro

  def mkreader(input, isa = Stupidedi::Interchange::FiveOhOne::InterchangeHeader.default)
    Stupidedi::Reader::DefaultReader.new(input, isa)
  end

  def mkinput(string, offset = 0)
    Stupidedi::Input.from_string(string, offset)
  end

  describe ".from_reader" do
    it "copies reader#input and reader#interchange_header" do
      input  = mock("input")
      isa    = mock("interchange_header")
      reader = mock("reader", :input => input, :interchange_header => isa)

      default = Stupidedi::Reader::DefaultReader.from_reader(reader)
      default.input.should eq(input)
      default.interchange_header.should eq(isa)
    end
  end

  describe "#default" do
    let(:reader) { mkreader "" }

    it "should return itself" do
      reader.default.should eq(reader)
    end
  end

  describe "#input" do
    it "should return the argument given to its constructor" do
      property { string }.check{|s| mkreader(s).input.should eq(s) }
    end
  end

  describe "#interchange_header" do
    let(:isa) { Stupidedi::Interchange::FiveOhOne::InterchangeHeader.default }

    it "should return the argument given to its constructor" do
      mkreader("", isa).interchange_header.should eq(isa)
    end
  end

  describe "#empty?" do
    context "when input is an empty string" do
      it "returns true" do
        mkreader("").should be_empty
      end
    end

    context "when input is a non-empty string" do
      it "returns false" do
        mkreader(" ").should_not be_empty
      end

      it "returns false" do
        mkreader("x").should_not be_empty
      end
    end
  end

  describe "#consume_prefix" do
    context "when search string is a prefix of the input" do
      it "is defined" do
        mkreader("abc").consume_prefix("ab").should be_defined
      end

      it "is defined", :random => true do
        property do
          string.bind{|s| [stream.agitate(s), s.take(between(1, s.length - 1))] }
        end.check do |input, prefix|
          mkreader(input).consume_prefix(prefix).should be_defined
        end
      end

      it "consumes the search string" do
        mkreader("abc").consume_prefix("ab").
          map{|remainder| remainder.input.should == "c" }
      end

      it "consumes the search string", :random => true do
        property do
          with(:size, between(1, 25)) do
            # Generate an input string (s), and split it at a random position to get prefix and suffix
            string.bind{|s| [stream.agitate(s), *s.split_at(between(0, s.length - 1))] }
          end
        end.check do |input, prefix, suffix|
          mkreader(input).consume_prefix(prefix).
            map{|remainder| Stupidedi::Reader.strip(remainder.input).should == suffix }
        end
      end

      it "updates the input offset" do
        reader = mkreader(mkinput("abc", 512))
        reader.consume_prefix("ab").
          map{|remainder| remainder.input.offset.should == 514 }
      end

      it "updates the input offset", :random => true do
        property do
          with(:size, between(1, 25)) do
            string.bind{|s| [integer.abs, s, *s.split_at(between(0, s.length - 1))] }
          end
        end.check do |offset, input, prefix, suffix|
          reader = mkreader(mkinput(input, offset))
          reader.consume_prefix(prefix).
            map{|remainder| remainder.input.offset.should == offset + prefix.length }
        end
      end
    end

    context "when the search string and input are equal" do
      it "is defined" do
        mkreader("abc").consume_prefix("abc").should be_defined
      end

      it "is defined", :random => true do
        property do
          with(:size, between(0, 25)) { string.bind{|s| [stream.agitate(s), s] }}
        end.check do |input, prefix|
          mkreader(input).consume_prefix(prefix).should be_defined
        end
      end

      it "consumes all input" do
        mkreader("abc").consume_prefix("abc").
          map{|remainder| remainder.should be_empty }
      end

      it "consumes all input", :random => true do
        property do
          with(:size, between(0, 25)) { string.bind{|s| [stream.agitate(s), s] }}
        end.check do |input, prefix|
          mkreader(input).consume_prefix(prefix).
            map{|remainder| Stupidedi::Reader.strip(remainder.input).should be_empty }
        end
      end

      it "updates the input offset" do
        reader = mkreader(mkinput("abc", 256))
        reader.consume_prefix("abc").
          map{|remainder| remainder.input.offset.should == 259 }
      end

      it "updates the input offset", :random => true do
        property do
          with(:size, between(0, 25)) { [string, integer.abs] }
        end.check do |input, offset|
          reader = mkreader(mkinput(input, offset))
          reader.consume_prefix(input).
            map{|remainder| remainder.input.offset == offset + input.length }
        end
      end
    end

    context "when the search string is not a prefix of the input" do
      it "is not defined" do
        mkreader("abc").consume_prefix("abd").should_not be_defined
      end

      it "is not defined", :random => true do
        property do
          with(:size, between(1, 25)) do
            # Generate an input string (s), and the search string is that with one character altered
            string.bind{|s| [stream.agitate(s), s.succ] }
          end
        end.check do |input, search|
          mkreader(input).consume_prefix(search).should_not be_defined
        end
      end

      it "produces an error message" do
        mkreader("abc").consume_prefix("abd").
          explanation.should == %[Found "abc" instead of "abd"]
      end

      it "encodes the error position" do
        reader = mkreader(mkinput("abc", 2048))
        reader.consume_prefix("abd").
          explanation.offset.should == 2048
      end
    end

    context "when the input is a suffix of the search string" do
      it "is not defined" do
        mkreader("bc").consume_prefix("abc").should_not be_defined
      end

      it "produces an error message" do
        mkreader("bc").consume_prefix("abc").
          explanation.should == %[Reached end of input without finding "abc"]
      end

      it "is not defined", :random => true do
        property do
          with(:size, between(1, 25)) do
            # Generate a search string (s), then the input is some suffix of that
            string.bind{|s| [stream.agitate(s.drop(between(1, s.length))), s] }
          end
        end.check do |input, search|
          mkreader(input).consume_prefix(search).should_not be_defined
        end
      end

      it "encodes the error position" do
        reader = mkreader(mkinput("bc", 2056))
        reader.consume_prefix("abc").
          explanation.offset.should == 2056
      end

      it "encodes the error position", :random => true
    end

    context "when the input is a prefix of the search string" do
      it "is not defined" do
        mkreader("ab").consume_prefix("abc").should_not be_defined
      end

      it "produces an error message" do
        mkreader("ab").consume_prefix("abc").
          explanation.should == %[Reached end of input without finding "abc"]
      end

      it "is not defined", :random => true do
        property do
          with(:size, between(1, 25)) do
            # Generate a search string (s), then the input is some prefix of that
            string.bind{|s| [stream.agitate(s.take(between(0, s.length - 1))), s] }
          end
        end.check do |input, search|
          mkreader(input).consume_prefix(search).should_not be_defined
        end
      end

      it "encodes the error position" do
        reader = mkreader(mkinput("ab", 512))
        reader.consume_prefix("abc").
          explanation.offset.should == 512
      end

      it "encodes the error position", :random => true
    end

    context "when the search string is empty" do
      it "is defined" do
        mkreader("abc").consume_prefix("").should be_defined
      end

      it "returns itself wrapped as a Either.success" do
        reader = mkreader("abc")
        reader.consume_prefix("").
          map{|remainder| remainder.should eq(reader) }
      end

      it "does not update the input offset" do
        reader = mkreader(mkinput("abc", 999))
        reader.consume_prefix("").
          map{|remainder| remainder.input.offset.should == 999 }
      end

      it "does not update the input offset", :random => true
    end
  end

  describe "#consume" do
    context "when input contains the search string" do
      it "is defined" do
        mkreader("abc def").consume("c d").should be_defined
      end

      it "is defined", :random => true

      it "updates the input offset" do
        mkreader(mkinput("abc def", 16)).consume("c d").
          map{|remainder| remainder.input.offset.should == 21 }
      end

      it "updates the input offset", :random => true

      it "consumes input up to and including the search string" do
        mkreader("abc def").consume("c d").
          map{|remainder| remainder.input.should == "ef" }
      end

      it "consumes input up to and including the search string", :random => true
    end

    context "when input does not contain the search string" do
      it "is not defined" do
        mkreader("abc def").consume("bcd").should_not be_defined
      end

      it "is not defined", :random => true

      it "produces an error message" do
        mkreader("abc def").consume("bcd").
          explanation.should == %[Reached end of input without finding "bcd"]
      end

      it "encodes the error position" do
        reader = mkreader(mkinput("abc def", 4096))
        reader.consume("bcd").
          explanation.offset.should == 4096
      end

      it "encodes the error position", :random => true
    end
  end

  describe "#read_delimiter" do
    context "when the input begins with a delimiter" do
      it "is defined", :random => true do
        property { stream.agitate(char.delimiter) }.check do |input|
          mkreader("#{input}...").read_delimiter.should be_defined
        end
      end

      it "reads the delimiter", :random => true do
        property { char.delimiter.bind{|s| [stream.agitate(s), s] }}.check do |input, delim|
          mkreader("#{input}...").read_delimiter.map do |result|
            result.value.should == delim
            Stupidedi::Reader.strip(result.remainder.input).should == "..."
          end
        end
      end

      it "updates the input offset", :random => true
    end

    context "when the input does not begin with a delimiter" do
      it "is not defined" do
        mkreader("abc").read_delimiter.should_not be_defined
      end

      it "is not defined", :random => true

      it "produces an error message" do
        mkreader("abc").read_delimiter.
          explanation.should == %[Found "a" instead of a delimiter]
      end

      it "encodes the error offset" do
        reader = mkreader(mkinput("abc", 5000))
        reader.read_delimiter.explanation.offset.should == 5000
      end

      it "encodes the error offset", :random => true
    end
  end

  describe "#read_simple_element" do
    pending
  end

  describe "#read_segment_id" do
    pending
  end

  describe "#read_segment" do
    pending
  end

  describe "#consume_interchange" do
    pending
  end

end
