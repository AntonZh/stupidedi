require "spec_helper"

describe Stupidedi::FiftyTen::Definitions::ElementDef do
  include QuickCheck::SerializedEdi::Macro

  let(:elements)   { Stupidedi::FiftyTen::Definitions::ElementTypes }
  let(:values)     { Stupidedi::Values }

  let(:dt) { elements::DT.new("DT", "Date", "Purpose", 8, 8) }

  describe "#reader" do
    let(:isa) { Stupidedi::Interchange::FiveOhOne::InterchangeHeader }

    context "SimpleElementDef" do
      context "date DT" do
        it "parses two-digit year YYMMDD" do
          dt.reader("100130*...", isa.default).read.map do |result|
            result.value.should_not be_proper
            result.value.year.should  == "10"
            result.value.month.should == "01"
            result.value.day.should   == "30"
            result.value.element_def.should == dt
            result.remainder.input.should == "*..."
          end.should be_defined
        end

        it "parses four-digit year CCYYMMDD" do
          dt.reader("20100130*...", isa.default).read.map do |result|
            result.value.should be_proper
            result.value.year.should  == "2010"
            result.value.month.should == "01"
            result.value.day.should   == "30"
          end.should be_defined
        end

        it "parses empty" do
          dt.reader("~...", isa.default).read.map do |result|
            result.value.should be_empty
            result.value.should == values::DateVal.empty
            result.remainder.input.should == "~..."
          end.should be_defined
        end

        it "parses empty", :random => true do
          property do
            with(document.delimiters) do
              [stream.agitate(stream.space(between(0, 16))), char.delimiter, stream.string, current.isa]
            end
          end.check do |space, delim, rest, isa|
            dt.reader("#{space}#{delim}#{rest}", isa).read.map do |result|
              result.value.should be_empty
              result.value.should == values::DateVal.empty
              result.remainder.input.should == "#{delim}#{rest}"
            end.should be_defined
          end
        end

        it "parses non-empty input with two-digit years", :random => true do
          property do
            with(document.delimiters) do
              [stream.pad(with(:size, 6) { element.dt }), char.delimiter, stream.string, current.isa].
                try{|xs| stream.agitate(xs.head).cons(xs) }
            end
          end.check do |agitated, data, delim, rest, isa|
            dt.reader("#{agitated}#{delim}#{rest}", isa).read.map do |result|
              data = data.strip
              result.value.year.should  == data.slice(0, 2)
              result.value.month.should == data.slice(2, 2)
              result.value.day.should   == data.slice(4, 2)
              result.remainder.input.should == "#{delim}#{rest}"
            end.should be_defined
          end
        end

        it "parses non-empty input with four-digit years", :random => true do
          property do
            with(document.delimiters) do
              [stream.pad(with(:size, 8) { element.dt }), char.delimiter, stream.string, current.isa].
                try{|xs| stream.agitate(xs.head).cons(xs) }
            end
          end.check do |agitated, data, delim, rest, isa|
            dt.reader("#{agitated}#{delim}#{rest}", isa).read.map do |result|
              data = data.strip
              result.value.year.should  == data.slice(0, 4)
              result.value.month.should == data.slice(4, 2)
              result.value.day.should   == data.slice(6, 2)
              result.remainder.input.should == "#{delim}#{rest}"
            end.should be_defined
          end
        end
      end

      context "date DT validation" do
        it "validates MM is from 01 to 12" do
          dt.reader("20101301*", isa.default).read.should_not be_defined
          dt.reader("101301*", isa.default).read.should_not be_defined
        end

        it "validates DD is from 01 to 31" do
          dt.reader("20100132*", isa.default).read.should_not be_defined
          dt.reader("100132*", isa.default).read.should_not be_defined
        end

        it "validates date" do
          dt.reader("19990229*", isa.default).read.should_not be_defined
        end

        it "produces an error message" do
          dt.reader("19990229*", isa.default).read.explanation.should ==
            %[Not a valid date '1999-02-29' from input "19990229"]
        end

        it "produces an error message" do
          dt.reader("19990229*", isa.default).read.explanation.should ==
            %[Not a valid date '1999-02-29' from input "19990229"]
        end

        it "encodes the error position"
      end

    end
  end
end
