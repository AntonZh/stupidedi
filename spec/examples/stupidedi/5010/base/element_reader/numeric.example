require "spec_helper"

describe Stupidedi::FiftyTen::Base::ElementDef do
  include QuickCheck::SerializedEdi::Macro

  let(:elements)   { Stupidedi::FiftyTen::Base::ElementTypes }
  let(:dictionary) { Stupidedi::FiftyTen::Base::ElementDictionary }
  let(:values)     { Stupidedi::Values }

  let(:n0) { elements::N0.new("N0", "Whole Number",   "Purpose", 1, 1) }
  let(:n1) { elements::N1.new("N1", "Tenths Place",   "Purpose", 1, 1) }
  let(:n2) { elements::N2.new("N2", "Money",          "Purpose", 1, 1) }
  let(:n3) { elements::N3.new("N3", "N.nnn",          "Purpose", 1, 1) }
  let(:n4) { elements::N4.new("N4", "N.nnnn",         "Purpose", 1, 1) }
  let(:n5) { elements::N5.new("N5", "N.nnnnn",        "Purpose", 1, 1) }
  let(:n6) { elements::N6.new("N6", "N.nnnnnn",       "Purpose", 1, 1) }
  let(:n7) { elements::N7.new("N7", "N.nnnnnnn",      "Purpose", 1, 1) }
  let(:n8) { elements::N8.new("N8", "N.nnnnnnnnn",    "Purpose", 1, 1) }
  let(:n9) { elements::N9.new("N9", "N.nnnnnnnnnn",   "Purpose", 1, 1) }

  describe "#reader" do
    let(:isa) { Stupidedi::Interchange::FiveOhOne::InterchangeHeader }

    context "SimpleElementDef" do
      context "numeric N0" do
        it "parses zero" do
          n0.reader("0~...", isa.default).read.map do |result|
            result.value.should == 0
            result.value.element_def.should == n0
            result.remainder.input.should == "~..."
          end.should be_defined
        end

        it "parses implicit decimal point" do
          n0.reader("9876543210~...", isa.default).read.map do |result|
            result.value.should == 9876543210
          end.should be_defined
        end

        it "parses leading minus sign" do
          n0.reader("-9876543210~...", isa.default).read.map do |result|
            result.value.should == -9876543210
          end.should be_defined
        end

        it "parses leading plus sign" do
          n0.reader("+9876543210~...", isa.default).read.map do |result|
            result.value.should == +9876543210
          end.should be_defined
        end

        it "parses empty" do
          n0.reader("~...", isa.default).read.map do |result|
            result.value.should be_empty
            result.value.should == values::NumericVal.empty
            result.remainder.input.should == "~..."
          end.should be_defined
        end

        it "parses empty", :random => true do
          property do
            with(document.delimiters) do
              [stream.agitate(stream.space(between(0, 16))), char.delimiter, stream.string, current.isa]
            end
          end.check do |space, delim, rest, isa|
            n0.reader("#{space}#{delim}#{rest}", isa).read.map do |result|
              result.value.should be_empty
              result.value.should == values::NumericVal.empty
              result.remainder.input.should == "#{delim}#{rest}"
            end.should be_defined
          end
        end

        it "parses non-empty input", :random => true do
          property do
            with(document.delimiters) { [element.nn, char.delimiter, stream.string, current.isa].
              try{|xs| stream.pad(stream.agitate(xs.head)).cons(xs) }}
          end.check do |agitated, data, delim, rest, isa|
            n0.reader("#{agitated}#{delim}#{rest}", isa).read.map do |result|
              result.value.should == BigDecimal(data)
              result.remainder.input.should == "#{delim}#{rest}"
            end.should be_defined
          end
        end
      end

      context "numeric N0 validation" do
        it "does not allow an explicit decimal point" do
          n0.reader(".1~...", isa.default).read.should_not be_defined
        end

        it "does not allow an explicit decimal point" do
          n0.reader("0.1~...", isa.default).read.should_not be_defined
        end

        it "produces an error message" do
          n0.reader("0.1~...", isa.default).read.explanation.
            should == %[Not a valid numeric (Nn) "0.1"]
        end

        it "encodes the error position"
      end

    end
  end
end
