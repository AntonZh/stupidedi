require "spec_helper"

describe Stupidedi::FiftyTen::Base::SegmentDef do
  include QuickCheck::SerializedEdi::Macro

  let(:elements)   { Stupidedi::FiftyTen::Base::ElementTypes }
  let(:dictionary) { Stupidedi::FiftyTen::Base::SegmentDictionary }

  let(:r)  { elements::R .new("R" , "Decimal Thing",  "Purpose", 1, 1) }
  let(:n0) { elements::N0.new("N0", "Whole Number",   "Purpose", 1, 1) }
  let(:n1) { elements::N1.new("N1", "Tenths Place",   "Purpose", 1, 1) }
  let(:n2) { elements::N2.new("N2", "Money",          "Purpose", 1, 1) }
  let(:n3) { elements::N3.new("N3", "N.nnn",          "Purpose", 1, 1) }
  let(:n4) { elements::N4.new("N4", "N.nnnn",         "Purpose", 1, 1) }
  let(:n5) { elements::N5.new("N5", "N.nnnnn",        "Purpose", 1, 1) }
  let(:n6) { elements::N6.new("N6", "N.nnnnnn",       "Purpose", 1, 1) }
  let(:n7) { elements::N7.new("N7", "N.nnnnnnn",      "Purpose", 1, 1) }
  let(:n8) { elements::N8.new("N8", "N.nnnnnnnnn",    "Purpose", 1, 1) }
  let(:n9) { elements::N9.new("N9", "N.nnnnnnnnnn",   "Purpose", 1, 1) }
  let(:id) { elements::ID.new("ID", "Qualifier",      "Purpose", 1, 1) }
  let(:an) { elements::AN.new("AN", "Free Text",      "Purpose", 1, 1) }
  let(:dt) { elements::DT.new("DT", "Date",           "Purpose", 8, 8) }
  let(:tm) { elements::TM.new("TM", "Time",           "Purpose", 4, 6) }

  describe "#empty" do
    pending
  end

  describe "#reader" do
    let(:isa) { Stupidedi::Interchange::FiveOhOne::InterchangeHeader.default }
    let(:des) { Stupidedi::FiftyTen::Base::Designations }

    def segment_def(id, *element_defs)
      Stupidedi::FiftyTen::Base::SegmentDef.new(id, "Segment Name", *element_defs.map{|e, rep, req| e.simple_use(req || des::ElementRequirement::M, rep || des.element_repetition(1)) })
    end

    context "with a single non-repeatable element def" do
      it "parses empty" do
        sdef = segment_def("REF", an)
        sdef.reader("REF~...", isa).read.map do |result|
          result.value.segment_def.should == sdef
          result.value.should be_empty

          result.value.element_vals.length.should == 1
          result.value[0].should be_empty

          result.remainder.input.should == "..."
        end.should be_defined
      end

      it "parses empty", :random => true

      it "parses non-empty input" do
        sdef = segment_def("N1", an)
        sdef.reader("N1*SOME TEXT~...", isa).read.map do |result|
          result.value.segment_def.should == sdef
          result.value.should_not be_empty

          result.value.element_vals.length.should == 1
          result.value[0].should_not be_empty
          result.value[0].should == "SOME TEXT"

          result.remainder.input.should == "..."
        end.should be_defined
      end

      it "parses non-empty input", :random => true

      context "when the input begins with the wrong segment id" do
        specify { segment_def("N1", an).reader("REF*2U*99XYZ~", isa).read.should_not be_defined }

        it "produces an error message" do
          result = segment_def("N1", an).reader("REF*2U*99XYZ~", isa).read
          result.explanation.should == %(Found "RE" instead of "N1")
        end

        it "encodes the error offset"
      end

      context "when the input is missing a segment terminator" do
        specify { segment_def("N1", an).reader("N1*SOME TEXT", isa).read.should_not be_defined }

        it "produces an error message" do
          result = segment_def("N1", an).reader("N1*SOME TEXT", isa).read
          result.explanation.should == "Reached end of input without finding a delimiter"
        end

        it "encodes the error offset"
      end

      context "when the input has more elements than the definition" do
        specify { segment_def("N1", an).reader("N1*SOME TEXT*EXTRA~...", isa).read.should_not be_defined }

        it "produces an error message" do
          result = segment_def("N1", an).reader("N1*SOME TEXT*EXTRA~...", isa).read
          result.explanation.should == %[Found an element separator "*" instead of a segment terminator]
        end

        it "encodes the error offset"
      end

      context "when the element fails to parse" do
        specify { segment_def("N1", dt).reader("N1*INVALID DATE~...", isa).read.should_not be_defined }

        it "produces an error message" do
          result = segment_def("N1", dt).reader("N1*INVALID DATE~...", isa).read
          result.explanation.should == %(Expected numeric characters for date (DT) "INVALID DATE")
        end

        it "encodes the error offset"
      end

      context "when the element occurs more than once" do
        specify { segment_def("N1", an).reader("N1*FIRST^SECOND~", isa).read.should_not be_defined }

        it "produces an error message" do
          result = segment_def("N1", an).reader("N1*FIRST^SECOND~", isa).read
          result.explanation.should == "Found a repetition separator following a non-repeatable element"
        end

        it "encodes the error offset"
      end
    end

    context "with a single repeated element def" do
      it "parses empty" do
        sdef = segment_def("N1", [an, des::element_repetition(2)])
        sdef.reader("N1~...", isa).read.map do |result|
          result.value.should be_empty
          result.value.segment_def.should == sdef
          result.value.element_vals.length.should == 1
          result.value[0].should be_empty
          result.remainder.input.should == "..."
        end.should be_defined
      end

      it "parses empty", :random => true

      it "parses when there are fewer than the defined maximum occurrences" do
        sdef = segment_def("N1", [an, des::element_repetition(10)])
        sdef.reader("N1*FIRST^SECOND~...", isa).read.map do |result|
          result.value.segment_def.should == sdef
          result.value.element_vals.length.should == 1

          result.value[0].length.should == 2
          result.value[0][0].should == "FIRST"
          result.value[0][1].should == "SECOND"

          result.remainder.input.should == "..."
        end.should be_defined
      end

      it "parses when there are the defined maximum of occurrences" do
        sdef = segment_def("N1", [an, des::element_repetition(2)])
        sdef.reader("N1*FIRST^SECOND~...", isa).read.map do |result|
          result.value.segment_def.should == sdef
          result.value.element_vals.length.should == 1

          result.value[0].length.should == 2
          result.value[0][0].should == "FIRST"
          result.value[0][1].should == "SECOND"

          result.remainder.input.should == "..."
        end.should be_defined
      end

      it "parses when there are more than the defined maximum occurrences" do
        sdef = segment_def("N1", [an, des::element_repetition(2)])
        sdef.reader("N1*FIRST^SECOND^THIRD~...", isa).read.map do |result|
          result.value.segment_def.should == sdef
          result.value.element_vals.length.should == 1

          result.value[0].length.should == 3
          result.value[0][0].should == "FIRST"
          result.value[0][1].should == "SECOND"
          result.value[0][2].should == "THIRD"

          result.remainder.input.should == "..."
        end.should be_defined
      end
    end

    context "with consecutive repeated element defs" do
      pending
    end
  end

  describe "#writer" do
    pending
  end
end
