require "spec_helper"

describe Stupidedi::FiftyTen::Base::ElementDef do
  include QuickCheck::SerializedEdi::Macro

  let(:elements)   { Stupidedi::FiftyTen::Base::ElementTypes }
  let(:dictionary) { Stupidedi::FiftyTen::Base::ElementDictionary }
  let(:values)     { Stupidedi::Values }

  let(:r)  { elements::R .new("R" , "Decimal Thing",  "Purpose", 1, 1) }
  let(:n0) { elements::N0.new("N0", "Whole Number",   "Purpose", 1, 1) }
  let(:n1) { elements::N1.new("N1", "Tenths Place",   "Purpose", 1, 1) }
  let(:n2) { elements::N2.new("N2", "Money",          "Purpose", 1, 1) }
  let(:n3) { elements::N3.new("N3", "N.nnn",          "Purpose", 1, 1) }
  let(:n4) { elements::N4.new("N4", "N.nnnn",         "Purpose", 1, 1) }
  let(:n5) { elements::N5.new("N5", "N.nnnnn",        "Purpose", 1, 1) }
  let(:n6) { elements::N6.new("N6", "N.nnnnnn",       "Purpose", 1, 1) }
  let(:n7) { elements::N7.new("N7", "N.nnnnnnn",      "Purpose", 1, 1) }
  let(:n8) { elements::N8.new("N8", "N.nnnnnnnnn",    "Purpose", 1, 1) }
  let(:n9) { elements::N9.new("N9", "N.nnnnnnnnnn",   "Purpose", 1, 1) }
  let(:id) { elements::ID.new("ID", "Qualifier",      "Purpose", 1, 1) }
  let(:an) { elements::AN.new("AN", "Free Text",      "Purpose", 1, 1) }
  let(:dt) { elements::DT.new("DT", "Date",           "Purpose", 8, 8) }
  let(:tm) { elements::TM.new("TM", "Time",           "Purpose", 4, 6) }

  describe "#empty" do
    context "SimpleElementDef" do
      context "decimal R" do
        subject { r.empty }
        it { should be_empty }
        it { should == values::NumericVal.empty }
        specify { subject.element_def == r }
      end

      context "numeric N0" do
        subject { n0.empty }
        it { should be_empty }
        it { should == values::NumericVal.empty }
        specify { subject.element_def == n0  }
      end

      # Cheating here to avoid boilerplate
      context "numeric Nn" do
        %w(n1 n2 n3 n4 n5 n6 n7 n8 n9).each do |nn|
          specify { send(nn).empty.should be_empty }
          specify { send(nn).empty.should == values::NumericVal.empty }
          specify { send(nn).empty.element_def == send(nn) }
        end
      end

      context "identifier ID" do
        subject { id.empty }
        it { should be_empty }
        it { should == values::IdentifierVal.empty }
        specify { subject.element_def == id }
      end

      context "string AN" do
        subject { an.empty }
        it { should be_empty }
        it { should == values::StringVal.empty }
        specify { subject.element_def == an }
      end

      context "date DT" do
        subject { dt.empty }
        it { should be_empty }
        it { should == values::DateVal.empty }
        specify { subject.element_def == dt }
      end

      context "time TM" do
        subject { tm.empty }
        it { should be_empty }
        it { should == values::TimeVal.empty }
        specify { subject.element_def == tm }
      end
    end

    context "CompositeElementDef" do
      pending
    end
  end

  describe "#reader" do
    let(:isa) { Stupidedi::Interchange::FiveOhOne::InterchangeHeader }

    context "SimpleElementDef" do
      context "decimal R" do
        it "parses explicit decimal point" do
          r.reader("12.34*...", isa.default).read.map do |result|
            result.value.should == 12.34
            result.value.element_def.should == r
            result.remainder.input.should == "*..."
          end.should be_defined
        end

        it "parses implicit decimal point" do
          r.reader("1234:...", isa.default).read.map do |result|
            result.value.should == 1234
          end.should be_defined
        end

        it "parses leading minus sign" do
          r.reader("-1.234~...", isa.default).read.map do |result|
            result.value.should == -1.234
          end.should be_defined
        end

        it "parses leading plus sign" do
          r.reader("+1234.~...", isa.default).read.map do |result|
            result.value.should == 1234
          end.should be_defined
        end

        it "parses leading zeros" do
          r.reader("0012.34*...", isa.default).read.map do |result|
            result.value.should == 12.34
          end.should be_defined
        end

        it "parses trailing zeros" do
          r.reader("1234.0000~...", isa.default).read.map do |result|
            result.value.should == 1234
          end.should be_defined
        end

        it "parses base 10 exponent" do
          r.reader("3.1E2^...", isa.default).read.map do |result|
            result.value.should == 310
          end.should be_defined
        end

        it "parses negative base 10 exponent" do
          r.reader("3.1E-2*...", isa.default).read.map do |result|
            result.value.should == 0.031
          end.should be_defined
        end

        it "parses positive base 10 exponent" do
          r.reader("3.1E+2~...", isa.default).read.map do |result|
            result.value.should == 310
          end.should be_defined
        end

        it "parses empty" do
          r.reader("~...", isa.default).read.map do |result|
            result.value.should be_empty
            result.value.should == values::NumericVal.empty
            result.remainder.input.should == "~..."
          end.should be_defined
        end

        it "parses empty", :random => true do
          property do
            with(document.delimiters) do
              [stream.agitate(stream.space(between(0, 16))), char.delimiter, stream.string, current.isa]
            end
          end.check do |space, delim, rest, isa|
            r.reader("#{space}#{delim}#{rest}", isa).read.map do |result|
              result.value.should be_empty
              result.value.should == values::NumericVal.empty
              result.remainder.input.should == "#{delim}#{rest}"
            end.should be_defined
          end
        end

        it "parses non-empty input", :random => true do
          property do
            with(document.delimiters) do
              [element.r, char.delimiter, stream.string, current.isa].
                try{|xs| stream.pad(stream.agitate(xs.head)).cons(xs) }
            end
          end.check do |agitated, data, delim, rest, isa|
            r.reader("#{agitated}#{delim}#{rest}", isa).read.map do |result|
              result.value.should == BigDecimal(data)
              result.remainder.input.should == "#{delim}#{rest}"
            end.should be_defined
          end
        end
      end

      context "decimal R input validation" do
        it "does not parse 'E'" do
          r.reader("E*", isa.default).read.should_not be_defined
        end

        it "does not parse 'E0'" do
          r.reader("E0*", isa.default).read.should_not be_defined
        end

        it "does not parse '0E'" do
          r.reader("0E*", isa.default).read.should_not be_defined
        end

        it "does not parse '1E1.1'" do
          r.reader("1E1.1*", isa.default).read.should_not be_defined
        end

        it "does not parse '1.2.3'" do
          r.reader("1.2.3*", isa.default).read.should_not be_defined
        end

        it "produces an error message" do
          r.reader("1.2.3*", isa.default).read.explanation.should ==
            %[Not a valid decimal (R) "1.2.3"]
        end

        it "encodes the error position"
      end

      context "numeric N0" do
        it "parses zero" do
          n0.reader("0~...", isa.default).read.map do |result|
            result.value.should == 0
            result.value.element_def.should == n0
            result.remainder.input.should == "~..."
          end.should be_defined
        end

        it "parses implicit decimal point" do
          n0.reader("9876543210~...", isa.default).read.map do |result|
            result.value.should == 9876543210
          end.should be_defined
        end

        it "parses leading minus sign" do
          n0.reader("-9876543210~...", isa.default).read.map do |result|
            result.value.should == -9876543210
          end.should be_defined
        end

        it "parses leading plus sign" do
          n0.reader("+9876543210~...", isa.default).read.map do |result|
            result.value.should == +9876543210
          end.should be_defined
        end

        it "parses empty" do
          n0.reader("~...", isa.default).read.map do |result|
            result.value.should be_empty
            result.value.should == values::NumericVal.empty
            result.remainder.input.should == "~..."
          end.should be_defined
        end

        it "parses empty", :random => true do
          property do
            with(document.delimiters) do
              [stream.agitate(stream.space(between(0, 16))), char.delimiter, stream.string, current.isa]
            end
          end.check do |space, delim, rest, isa|
            n0.reader("#{space}#{delim}#{rest}", isa).read.map do |result|
              result.value.should be_empty
              result.value.should == values::NumericVal.empty
              result.remainder.input.should == "#{delim}#{rest}"
            end.should be_defined
          end
        end

        it "parses non-empty input", :random => true do
          property do
            with(document.delimiters) { [element.nn, char.delimiter, stream.string, current.isa].
              try{|xs| stream.pad(stream.agitate(xs.head)).cons(xs) }}
          end.check do |agitated, data, delim, rest, isa|
            n0.reader("#{agitated}#{delim}#{rest}", isa).read.map do |result|
              result.value.should == BigDecimal(data)
              result.remainder.input.should == "#{delim}#{rest}"
            end.should be_defined
          end
        end
      end

      context "numeric N0 input validation" do
        it "does not parse explicit decimal point" do
          n0.reader("0~...", isa.default).read.map do |result|
            result.value.should == 0
          end.should be_defined
        end

        it "produces an error message"

        it "encodes the error position"
      end

      context "identifier ID" do
        it "parses trailing spaces" do
          id.reader("AB   *...", isa.default).read.map do |result|
            result.value.should == "AB"
            result.value.element_def.should == id
            result.remainder.input.should == "*..."
          end.should be_defined
        end

        it "parses leading spaces" do
          id.reader("   AB*...", isa.default).read.map do |result|
            result.value.should == "   AB"
          end.should be_defined
        end

        it "parses empty" do
          id.reader("~...", isa.default).read.map do |result|
            result.value.should be_empty
            result.value.should == values::IdentifierVal.empty
            result.remainder.input.should == "~..."
          end.should be_defined
        end

        it "parses empty", :random => true do
          property do
            with(document.delimiters) do
              [stream.agitate(stream.space(between(0, 16))), char.delimiter, stream.string, current.isa]
            end
          end.check do |space, delim, rest, isa|
            id.reader("#{space}#{delim}#{rest}", isa).read.map do |result|
              result.value.should be_empty
              result.value.should == values::IdentifierVal.empty
              result.remainder.input.should == "#{delim}#{rest}"
            end.should be_defined
          end
        end

        it "parses non-empty input", :random => true do
          property do
            with(document.delimiters) do
              [stream.pad(element.id), char.delimiter, stream.string, current.isa].
                try{|xs| stream.agitate(xs.head).cons(xs) }
            end
          end.check do |agitated, data, delim, rest, isa|
            id.reader("#{agitated}#{delim}#{rest}", isa).read.map do |result|
              result.value.should == data.rstrip
              result.remainder.input.should == "#{delim}#{rest}"
            end.should be_defined
          end
        end
      end

      context "string AN" do
        it "parses trailing spaces" do
          an.reader("FOO BAR   *...", isa.default).read.map do |result|
            result.value.should == "FOO BAR"
            result.value.element_def.should == an
            result.remainder.input.should == "*..."
          end.should be_defined
        end

        it "parses leading spaces" do
          an.reader("   FOO BAR*...", isa.default).read.map do |result|
            result.value.should == "   FOO BAR"
          end.should be_defined
        end

        it "parses basic character set" do
          delims = QuickCheck::SerializedEdi.value { current.delimiters.values }
          string = Stupidedi::Reader.basic_characters.reject{|x| delims.include?(x) }.join

          an.reader("#{string}*...", isa.default).read.map do |result|
            result.value.should == string
          end.should be_defined
        end

        it "parses extended character set" do
          delims = QuickCheck::SerializedEdi.value { current.delimiters.values }
          string = Stupidedi::Reader.extended_characters.reject{|x| delims.include?(x) }.join

          an.reader("#{string}*...", isa.default).read.map do |result|
            result.value.should == string
          end.should be_defined
        end

        it "ignores control characters" do
          string = Stupidedi::Reader.control_characters.join

          an.reader("#{string}*...", isa.default).read.map do |result|
            result.value.should == values::StringVal.empty
          end.should be_defined
        end

        it "parses empty" do
          an.reader("~...", isa.default).read.map do |result|
            result.value.should be_empty
            result.value.should == values::StringVal.empty
            result.remainder.input.should == "~..."
          end.should be_defined
        end

        it "parses empty", :random => true do
          property do
            with(document.delimiters) do
              [stream.agitate(stream.space(between(0, 16))), char.delimiter, stream.string, current.isa]
            end
          end.check do |space, delim, rest, isa|
            an.reader("#{space}#{delim}#{rest}", isa).read.map do |result|
              result.value.should be_empty
              result.value.should == values::StringVal.empty
              result.remainder.input.should == "#{delim}#{rest}"
            end.should be_defined
          end
        end

        it "parses non-empty input", :random => true do
          property do
            with(document.delimiters) do
              [stream.pad(element.an), char.delimiter, stream.string, current.isa].
                try{|xs| stream.agitate(xs.head).cons(xs) }
            end
          end.check do |agitated, data, delim, rest, isa|
            an.reader("#{agitated}#{delim}#{rest}", isa).read.map do |result|
              result.value.should == data.rstrip
              result.remainder.input.should == "#{delim}#{rest}"
            end.should be_defined
          end
        end
      end

      context "date DT" do
        it "parses two-digit year YYMMDD" do
          dt.reader("100130*...", isa.default).read.map do |result|
            result.value.should_not be_proper
            result.value.year.should  == "10"
            result.value.month.should == "01"
            result.value.day.should   == "30"
            result.value.element_def.should == dt
            result.remainder.input.should == "*..."
          end.should be_defined
        end

        it "parses four-digit year CCYYMMDD" do
          dt.reader("20100130*...", isa.default).read.map do |result|
            result.value.should be_proper
            result.value.year.should  == "2010"
            result.value.month.should == "01"
            result.value.day.should   == "30"
          end.should be_defined
        end

        it "parses empty" do
          dt.reader("~...", isa.default).read.map do |result|
            result.value.should be_empty
            result.value.should == values::DateVal.empty
            result.remainder.input.should == "~..."
          end.should be_defined
        end

        it "parses empty", :random => true do
          property do
            with(document.delimiters) do
              [stream.agitate(stream.space(between(0, 16))), char.delimiter, stream.string, current.isa]
            end
          end.check do |space, delim, rest, isa|
            dt.reader("#{space}#{delim}#{rest}", isa).read.map do |result|
              result.value.should be_empty
              result.value.should == values::DateVal.empty
              result.remainder.input.should == "#{delim}#{rest}"
            end.should be_defined
          end
        end

        it "parses non-empty input with two-digit years", :random => true do
          property do
            with(document.delimiters) do
              [stream.pad(with(:size, 6) { element.dt }), char.delimiter, stream.string, current.isa].
                try{|xs| stream.agitate(xs.head).cons(xs) }
            end
          end.check do |agitated, data, delim, rest, isa|
            dt.reader("#{agitated}#{delim}#{rest}", isa).read.map do |result|
              data = data.strip
              result.value.year.should  == data.slice(0, 2)
              result.value.month.should == data.slice(2, 2)
              result.value.day.should   == data.slice(4, 2)
              result.remainder.input.should == "#{delim}#{rest}"
            end.should be_defined
          end
        end

        it "parses non-empty input with four-digit years", :random => true do
          property do
            with(document.delimiters) do
              [stream.pad(with(:size, 8) { element.dt }), char.delimiter, stream.string, current.isa].
                try{|xs| stream.agitate(xs.head).cons(xs) }
            end
          end.check do |agitated, data, delim, rest, isa|
            dt.reader("#{agitated}#{delim}#{rest}", isa).read.map do |result|
              data = data.strip
              result.value.year.should  == data.slice(0, 4)
              result.value.month.should == data.slice(4, 2)
              result.value.day.should   == data.slice(6, 2)
              result.remainder.input.should == "#{delim}#{rest}"
            end.should be_defined
          end
        end
      end

      context "date DT input validation" do
        it "validates MM is from 01 to 12" do
          dt.reader("20101301*", isa.default).read.should_not be_defined
          dt.reader("101301*", isa.default).read.should_not be_defined
        end

        it "validates DD is from 01 to 31" do
          dt.reader("20100132*", isa.default).read.should_not be_defined
          dt.reader("100132*", isa.default).read.should_not be_defined
        end

        it "validates date" do
          dt.reader("19990229*", isa.default).read.should_not be_defined
        end

        it "produces an error message" do
          dt.reader("19990229*", isa.default).read.explanation.should ==
            %[Not a valid year(1999) month(02) day(29) for date (DT) "19990229"]
        end

        it "produces an error message" do
          dt.reader("19990229*", isa.default).read.explanation.should ==
            %[Not a valid year(1999) month(02) day(29) for date (DT) "19990229"]
        end

        it "encodes the error position"
      end

      context "time TM" do
        it "parses HH" do
          tm.reader("12*...", isa.default).read.map do |result|
            result.value.hour.should   == "12"
            result.value.minute.should be_nil
            result.value.second.should be_nil
            result.value.element_def.should == tm
            result.remainder.input.should == "*..."
          end.should be_defined
        end

        it "parses HHMM" do
          tm.reader("1230*...", isa.default).read.map do |result|
            result.value.hour.should   == "12"
            result.value.minute.should == "30"
            result.value.second.should be_nil
          end.should be_defined
        end

        it "parses HHMMSS" do
          tm.reader("123015*...", isa.default).read.map do |result|
            result.value.hour.should   == "12"
            result.value.minute.should == "30"
            result.value.second.should == "15"
          end.should be_defined
        end

        it "parses HHMMSSd..d" do
          tm.reader("1245309999*...", isa.default).read.map do |result|
            result.value.hour.should   == "12"
            result.value.minute.should == "45"
            result.value.second.should == "309999"
          end.should be_defined
        end

        it "parses empty" do
          tm.reader("~...", isa.default).read.map do |result|
            result.value.should be_empty
            result.value.should == values::TimeVal.empty
            result.remainder.input.should == "~..."
          end.should be_defined
        end

        it "parses empty", :random => true do
          property do
            with(document.delimiters) do
              [stream.agitate(stream.space(between(0, 16))), char.delimiter, stream.string, current.isa]
            end
          end.check do |space, delim, rest, isa|
            tm.reader("#{space}#{delim}#{rest}", isa).read.map do |result|
              result.value.should be_empty
              result.value.should == values::TimeVal.empty
              result.remainder.input.should == "#{delim}#{rest}"
            end.should be_defined
          end
        end

        it "parses non-empty input with two digits", :random => true do
          property do
            with(document.delimiters) do
              [stream.pad(with(:size, 2) { element.tm }), char.delimiter, stream.string, current.isa].
                try{|xs| stream.agitate(xs.head).cons(xs) }
            end
          end.check do |agitated, data, delim, rest, isa|
            tm.reader("#{agitated}#{delim}#{rest}", isa).read.map do |result|
              data = data.strip
              result.value.hour.should    == data
              result.value.minute.should  == nil
              result.value.second.should  == nil
              result.remainder.input.should == "#{delim}#{rest}"
            end.should be_defined
          end
        end

        it "parses non-empty input with four digits", :random => true do
          property do
            with(document.delimiters) do
              [stream.pad(with(:size, 4) { element.tm }), char.delimiter, stream.string, current.isa].
                try{|xs| stream.agitate(xs.head).cons(xs) }
            end
          end.check do |agitated, data, delim, rest, isa|
            tm.reader("#{agitated}#{delim}#{rest}", isa).read.map do |result|
              data = data.strip
              result.value.hour.should    == data.slice(0, 2)
              result.value.minute.should  == data.slice(2, 2)
              result.value.second.should  == nil
              result.remainder.input.should == "#{delim}#{rest}"
            end.should be_defined
          end
        end

        it "parses non-empty input with six digits", :random => true do
          property do
            with(document.delimiters) do
              [stream.pad(with(:size, 6) { element.tm }), char.delimiter, stream.string, current.isa].
                try{|xs| stream.agitate(xs.head).cons(xs) }
            end
          end.check do |agitated, data, delim, rest, isa|
            tm.reader("#{agitated}#{delim}#{rest}", isa).read.map do |result|
              data = data.strip
              result.value.hour.should    == data.slice(0, 2)
              result.value.minute.should  == data.slice(2, 2)
              result.value.second.should  == data.slice(4, 2)
              result.remainder.input.should == "#{delim}#{rest}"
            end.should be_defined
          end
        end

        it "parses non-empty input with more than six digits", :random => true do
          property do
            with(document.delimiters) do
              [stream.pad(with(:size, between(7, 14)) { element.tm }), char.delimiter, stream.string, current.isa].
                try{|xs| stream.agitate(xs.head).cons(xs) }
            end
          end.check do |agitated, data, delim, rest, isa|
            tm.reader("#{agitated}#{delim}#{rest}", isa).read.map do |result|
              data = data.strip
              result.value.hour.should    == data.slice(0, 2)
              result.value.minute.should  == data.slice(2, 2)
              result.value.second.should  == data.slice(4..-1)
              result.remainder.input.should == "#{delim}#{rest}"
            end.should be_defined
          end
        end
      end

      context "time TM validation" do
        it "requires two-digit hour" do
          tm.reader("2*", isa.default).read.should_not be_defined
        end

        it "requires two-digit minute" do
          tm.reader("123*", isa.default).read.should_not be_defined
        end

        it "requires two-digit second" do
          tm.reader("12305*", isa.default).read.should_not be_defined
        end

        it "validates hour is from 00 to 24" do
          tm.reader("25*", isa.default).read.should_not be_defined
        end

        it "validates minute is from 00 to 60" do
          tm.reader("1261*", isa.default).read.should_not be_defined
        end

        it "validates second is from 00 to 60" do
          tm.reader("12306099*", isa.default).read.should_not be_defined
        end

        it "produces an error message" do
          tm.reader("12306099*", isa.default).read.explanation.should ==
            %[Not a valid hour(12) minute(30) second(6099) for time (TM) "12306099"]
        end

        it "encodes the error position"
      end

    end

    context "CompositeElementDef" do
      let(:req) { Stupidedi::FiftyTen::Base::Designations::ElementRequirement }

      def composite_def(*element_defs)
        Stupidedi::FiftyTen::Base::CompositeElementDef.new("XX", "Name", "Purpose", *element_defs.map{|e| e.component_use(req::M) })
      end

      def composite_val(cdef, *component_vals)
        Stupidedi::Values::CompositeElementVal.new(cdef, component_vals)
      end

      context "defined with a single component element" do
        it "parses empty" do
          composite_def(dt).reader("~...", isa.default).read.map do |result|
            result.value.should be_empty
            result.value.component_element_vals.length.should == 1
            result.value[0].should == values::DateVal.empty
            result.remainder.input.should == "~..."
          end.should be_defined
        end

        it "parses empty", :random => true do
          # Note we cannot lookup these methods from within property { ... }, but
          # accessing local variables declared outside the closure (like so) does work.
          component_defs = [n0, n1, n2, n3, n4, n5, n6, n7, n8, n9, r, id, an, dt, tm]

          property do
            # Create an interchange header with random delimiters
            with(document.delimiters) do
              # Choose a random simple element definition
              ce = choose(component_defs)

              # Choose a random delimiter from the definition of isa, generated above
              delim = char.delimiter
              guard delim != component_separator

              # Generate a sequence of spaces ' ' of random length, and then insert
              # control characters into it at random positions
              space = stream.agitate(stream.space(between(0, 16)))

              # Pass this value to the block given to check below
              [space, delim, stream.string, ce, current.isa]
            end
          end.check do |space, delim, rest, ce, isa|
            # Convert the simple element definition into a one-element composite element definition
            composite_def(ce).reader("#{space}#{delim}#{rest}", isa).read.map do |result|
              # The result.value is a CompositeElementVal
              result.value.should be_empty

              # Only a single component was parsed
              result.value.component_element_vals.length.should == 1

              # The delimiter and anything after it was not parsed
              result.remainder.input.should == "#{delim}#{rest}"
            end.should be_defined
          end
        end

        # TODO this is error handling
        it "parses no more than the defined number of elements" do
          result = composite_def(dt).reader("20001231:0030:XYZ...", isa.default).read
          result.should_not be_defined
          result.explanation.should == %[Found a component separator ":" instead of an element separator, segment terminator, or repetition separator]
        end

        it "parses non-empty input"

        it "parses non-empty input", :random => true do
          component_defs = [n0, n1, n2, n3, n4, n5, n6, n7, n8, n9, r, id, an, dt, tm]

          property do
            with(document.delimiters) do
              ce    = choose(component_defs)
              delim = char.delimiter
              guard delim != component_separator

              [stream.pad(stream.agitate(element(ce))), delim, stream.string, ce, current.isa]
            end
          end.check do |data, delim, rest, ce, isa|
            cdef = composite_def(ce)
            cdef.reader("#{data}#{delim}#{rest}", isa).read.tap do |result|
              # Check that parsing the string with SimpleElementDef produces the same value
              #   (note we're comparing Either to Either in this block (unlike map below))
              result.should == ce.reader("#{data}#{delim}#{rest}", isa).read.map{|x| x.map{|y| composite_val(cdef, y) }}
            end.map do |result|
              result.value.component_element_vals.length.should == 1

              # Note that even if the delimiter is the component separator, the reader does not
              # consume it. That means at this point, we know the number of component elements
              # and promise to read no more than that number of elements from the input stream.
              result.remainder.input.should == "#{delim}#{rest}"
            end.should be_defined
          end
        end
      end

      context "defined with more than one component element" do
        it "parses empty" do
          dictionary::C023.reader("*...", isa.default).read.map do |result|
            result.value.should be_empty
            result.value.element_def.should == dictionary::C023
            result.value.component_element_vals.length.should == 3

            result.value[0].should be_empty
            result.value[1].should be_empty
            result.value[2].should be_empty

            result.value[0].should == values::StringVal.empty
            result.value[1].should == values::IdentifierVal.empty
            result.value[2].should == values::IdentifierVal.empty

            result.remainder.input.should == "*..."
          end.should be_defined
        end

        it "parses empty", :random => true do
          component_defs = [n0, n1, n2, n3, n4, n5, n6, n7, n8, n9, r, id, an, dt, tm]

          property do
            with(document.delimiters) do
              with(:size, between(2, 8)) do
                delim  = char.delimiter
                guard delim != component_separator

                cs     = array { choose(component_defs) }
                blanks = array { stream.agitate(stream.space(between(0, 16))) }

                [blanks, delim, stream.string, cs, current.isa]
              end
            end
          end.check do |blanks, delim, rest, cs, isa|
            composite_def(*cs).reader("#{blanks.join(isa.component_separator)}#{delim}#{rest}", isa).read.map do |result|
              result.value.should be_empty
              result.value.component_element_vals.length.should == cs.length
              result.remainder.input.should == "#{delim}#{rest}"
            end.should be_defined
          end
        end

        # TODO this is error handling
        it "parses no more than the defined number of elements" do
          result = composite_def(dt, tm).reader("20001231:0030:XYZ...", isa.default).read
          result.should_not be_defined
        end

        it "parses input with first few elements not present" do
          dictionary::C023.reader("::8*...", isa.default).read.map do |result|
            result.value.should_not be_empty
            result.value.element_def.should == dictionary::C023
            result.value[0].should be_empty
            result.value[1].should be_empty
            result.value[2].should == "8"
            result.remainder.input.should == "*..."
          end.should be_defined
        end

        it "parses input with first few elements not present", :random => true do
          component_defs = [n0, n1, n2, n3, n4, n5, n6, n7, n8, n9, r, id, an, dt, tm]

          property do
            with(document.delimiters) do
              with(:size, between(2, 16)) do
                delim  = char.delimiter
                guard delim != component_separator

                cs     = array { choose(component_defs) }
                blanks = with(:size, between(1, cs.length - 1)) { array { stream.agitate(stream.space(between(0, 16))) }}
                values = cs.last(size - blanks.length).map {|c| stream.agitate(element(c)) }

                [blanks, values, delim, stream.string, cs, current.isa]
              end
            end
          end.check do |blanks, values, delim, rest, cs, isa|
            input = "#{(blanks + values).join(isa.component_separator)}#{delim}#{rest}"

            composite_def(*cs).reader(input, isa).read.map do |result|
              result.value.should_not be_empty
              result.value.component_element_vals.length.should == cs.length
              result.remainder.input.should == "#{delim}#{rest}"

              # The first few components should be blank
              result.value.component_element_vals.take(blanks.length).all?(&:empty?).should be_true

              # The remaining components should not be blank
              result.value.component_element_vals.drop(blanks.length).any?(&:empty?).should be_false
            end.should be_defined
          end
        end

        it "parses input with middle elements not present" do
          dictionary::C023.reader("11::8*...", isa.default).read.map do |result|
            result.value.should_not be_empty
            result.value.element_def.should == dictionary::C023
            result.value[0].should == "11"
            result.value[1].should be_empty
            result.value[2].should == "8"
            result.remainder.input.should == "*..."
          end.should be_defined
        end

        it "parses input with middle elements not present", :random => true do
          component_defs = [n0, n1, n2, n3, n4, n5, n6, n7, n8, n9, r, id, an, dt, tm]

          property do
            with(document.delimiters) do
              with(:size, between(3, 16)) do
                delim  = char.delimiter
                guard delim != component_separator

                cs     = array { choose(component_defs) }
                head   = cs.take(between(1, cs.length - 2)).map{|c| stream.agitate(element(c)) }
                blanks = map(between(1, cs.length - head.length - 1)) { stream.agitate(stream.space(between(0, 16))) }
                tail   = cs.drop(head.length + blanks.length).map{|c| stream.agitate(element(c)) }

                [head, blanks, tail, delim, stream.string, cs, current.isa]
              end
            end
          end.check do |head, blanks, tail, delim, rest, cs, isa|
            input = [head, blanks, tail].map{|x| x.join(isa.component_separator) }.join(isa.component_separator) << delim << rest

            composite_def(*cs).reader(input, isa).read.map do |result|
              result.value.should_not be_empty
              result.value.component_element_vals.length.should == cs.length
              result.remainder.input.should == "#{delim}#{rest}"

              # The first few components should be blank
              result.value.component_element_vals.take(head.length).any?(&:empty?).should be_false

              # The remaining components should not be blank
              result.value.component_element_vals.slice(head.length, blanks.length).all?(&:empty?).should be_true

              # The remaining components should not be blank
              result.value.component_element_vals.drop(head.length + blanks.length).any?(&:empty?).should be_false
            end.should be_defined
          end
        end

        it "parses input with last few elements not present (whitespace)" do
          dictionary::C023.reader("11:  :  *...", isa.default).read.map do |result|
            result.value.should_not be_empty
            result.value.element_def.should == dictionary::C023
            result.value[0].should == "11"
            result.value[1].should be_empty
            result.value[2].should be_empty
            result.remainder.input.should == "*..."
          end.should be_defined
        end

        it "parses input with last few elements not present (whitespace)", :random => true do
          component_defs = [n0, n1, n2, n3, n4, n5, n6, n7, n8, n9, r, id, an, dt, tm]

          property do
            with(document.delimiters) do
              with(:size, between(3, 16)) do
                delim  = char.delimiter
                guard delim != component_separator

                cs     = array { choose(component_defs) }
                values = cs.take(between(1, cs.length - 1)).map{|c| stream.agitate(element(c)) }
                blanks = map(size - values.length) { stream.agitate(stream.space(between(0, 16))) }

                [values, blanks, delim, stream.string, cs, current.isa]
              end
            end
          end.check do |values, blanks, delim, rest, cs, isa|
            input = "#{(values + blanks).join(isa.component_separator)}#{delim}#{rest}"

            composite_def(*cs).reader(input, isa).read.map do |result|
              result.value.should_not be_empty
              result.value.component_element_vals.length.should == cs.length
              result.remainder.input.should == "#{delim}#{rest}"

              # The first few components should be blank
              result.value.component_element_vals.take(values.length).any?(&:empty?).should be_false

              # The remaining components should not be blank
              result.value.component_element_vals.drop(values.length).all?(&:empty?).should be_true
            end.should be_defined
          end
        end

        it "parses input with last few elements not present (delimiters)" do
          dictionary::C023.reader("11::*...", isa.default).read.map do |result|
            result.value.should_not be_empty
            result.value.element_def.should == dictionary::C023
            result.value[0].should == "11"
            result.value[1].should be_empty
            result.value[2].should be_empty
            result.remainder.input.should == "*..."
          end.should be_defined
        end

        it "parses input with last few elements not present (delimiters)", :random => true do
          component_defs = [n0, n1, n2, n3, n4, n5, n6, n7, n8, n9, r, id, an, dt, tm]

          property do
            with(document.delimiters) do
              with(:size, between(3, 16)) do
                delim   = char.delimiter
                guard delim != component_separator

                cs      = array { choose(component_defs) }
                values  = cs.take(between(1, cs.length - 1)).map{|c| stream.agitate(element(c)) }
                nblanks = size - values.length

                [values, nblanks, delim, stream.string, cs, current.isa]
              end
            end
          end.check do |values, nblanks, delim, rest, cs, isa|
            input = "#{(values + ([''] * nblanks)).join(isa.component_separator)}#{delim}#{rest}"

            composite_def(*cs).reader(input, isa).read.map do |result|
              result.value.should_not be_empty
              result.value.component_element_vals.length.should == cs.length
              result.remainder.input.should == "#{delim}#{rest}"

              # The first few components should be blank
              result.value.component_element_vals.take(values.length).any?(&:empty?).should be_false

              # The remaining components should not be blank
              result.value.component_element_vals.drop(values.length).all?(&:empty?).should be_true
            end.should be_defined
          end
        end

        it "parses input with last few elements not present (truncated)" do
          dictionary::C023.reader("11*...", isa.default).read.map do |result|
            result.value.should_not be_empty
            result.value.element_def.should == dictionary::C023
            result.value[0].should == "11"
            result.value[1].should be_empty
            result.value[2].should be_empty
            result.remainder.input.should == "*..."
          end.should be_defined
        end

        it "parses input with last few elements not present (truncated)", :random => true do
          component_defs = [n0, n1, n2, n3, n4, n5, n6, n7, n8, n9, r, id, an, dt, tm]

          property do
            with(document.delimiters) do
              with(:size, between(3, 16)) do
                delim = char.delimiter
                guard delim != component_separator

                cs     = array { choose(component_defs) }
                values = cs.take(between(1, cs.length - 1)).map{|c| stream.agitate(element(c)) }

                [values, delim, stream.string, cs, current.isa]
              end
            end
          end.check do |values, delim, rest, cs, isa|
            input = "#{values.join(isa.component_separator)}#{delim}#{rest}"

            composite_def(*cs).reader(input, isa).read.map do |result|
              result.value.should_not be_empty
              result.value.component_element_vals.length.should == cs.length
              result.remainder.input.should == "#{delim}#{rest}"

              # The first few components should be blank
              result.value.component_element_vals.take(values.length).any?(&:empty?).should be_false

              # The remaining components should not be blank
              result.value.component_element_vals.drop(values.length).all?(&:empty?).should be_true
            end.should be_defined
          end
        end

        it "parses input with all elements present" do
          dictionary::C023.reader("11:B:8*...", isa.default).read.map do |result|
            result.value.should_not be_empty
            result.value.element_def.should == dictionary::C023
            result.value[0].should == "11"
            result.value[1].should == "B"
            result.value[2].should == "8"
            result.remainder.input.should == "*..."
          end.should be_defined
        end

        it "parses input with all elements present", :random => true do
          component_defs = [n0, n1, n2, n3, n4, n5, n6, n7, n8, n9, r, id, an, dt, tm]

          property do
            with(document.delimiters) do
              with(:size, between(3, 16)) do
                delim  = char.delimiter
                guard delim != component_separator

                cs     = array { choose(component_defs) }
                values = cs.map{|c| stream.agitate(element(c)) }

                [values, delim, stream.string, cs, current.isa]
              end
            end
          end.check do |values, delim, rest, cs, isa|
            input = "#{values.join(isa.component_separator)}#{delim}#{rest}"

            composite_def(*cs).reader(input, isa).read.map do |result|
              result.value.should_not be_empty
              result.value.component_element_vals.length.should == cs.length
              result.remainder.input.should == "#{delim}#{rest}"

              # None of the components should be blank
              result.value.component_element_vals.any?(&:empty?).should be_false
            end.should be_defined
          end
        end

      end
    end
  end

  describe "#writer" do
    context "SimpleElementDef" do
      pending
    end

    context "CompositeElementDef" do
      pending
    end
  end

end
