require "spec_helper"

describe Stupidedi::FiftyTen::Base::ElementDef do
  include QuickCheck::SerializedEdi::Macro

  let(:elements)   { Stupidedi::FiftyTen::Base::ElementTypes }
  let(:dictionary) { Stupidedi::FiftyTen::Base::ElementDictionary }
  let(:values)     { Stupidedi::Values }

  let(:r)  { elements::R .new("R" , "Decimal Thing",  "Purpose", 1, 1) }
  let(:n0) { elements::N0.new("N0", "Whole Number",   "Purpose", 1, 1) }
  let(:n1) { elements::N1.new("N1", "Tenths Place",   "Purpose", 1, 1) }
  let(:n2) { elements::N2.new("N2", "Money",          "Purpose", 1, 1) }
  let(:n3) { elements::N3.new("N3", "N.nnn",          "Purpose", 1, 1) }
  let(:n4) { elements::N4.new("N4", "N.nnnn",         "Purpose", 1, 1) }
  let(:n5) { elements::N5.new("N5", "N.nnnnn",        "Purpose", 1, 1) }
  let(:n6) { elements::N6.new("N6", "N.nnnnnn",       "Purpose", 1, 1) }
  let(:n7) { elements::N7.new("N7", "N.nnnnnnn",      "Purpose", 1, 1) }
  let(:n8) { elements::N8.new("N8", "N.nnnnnnnnn",    "Purpose", 1, 1) }
  let(:n9) { elements::N9.new("N9", "N.nnnnnnnnnn",   "Purpose", 1, 1) }
  let(:id) { elements::ID.new("ID", "Qualifier",      "Purpose", 1, 1) }
  let(:an) { elements::AN.new("AN", "Free Text",      "Purpose", 1, 1) }
  let(:dt) { elements::DT.new("DT", "Date",           "Purpose", 8, 8) }
  let(:tm) { elements::TM.new("TM", "Time",           "Purpose", 4, 6) }

  describe "#empty" do
    context "SimpleElementDef" do
      context "decimal R" do
        subject { r.empty }
        it { should be_empty }
        it { should == values::NumericVal.empty }
        specify { subject.element_def == r }
      end

      context "numeric N0" do
        subject { n0.empty }
        it { should be_empty }
        it { should == values::NumericVal.empty }
        specify { subject.element_def == n0  }
      end

      # Cheating here to avoid boilerplate
      context "numeric Nn" do
        %w(n1 n2 n3 n4 n5 n6 n7 n8 n9).each do |nn|
          specify { send(nn).empty.should be_empty }
          specify { send(nn).empty.should == values::NumericVal.empty }
          specify { send(nn).empty.element_def == send(nn) }
        end
      end

      context "identifier ID" do
        subject { id.empty }
        it { should be_empty }
        it { should == values::IdentifierVal.empty }
        specify { subject.element_def == id }
      end

      context "string AN" do
        subject { an.empty }
        it { should be_empty }
        it { should == values::StringVal.empty }
        specify { subject.element_def == an }
      end

      context "date DT" do
        subject { dt.empty }
        it { should be_empty }
        it { should == values::DateVal.empty }
        specify { subject.element_def == dt }
      end

      context "time TM" do
        subject { tm.empty }
        it { should be_empty }
        it { should == values::TimeVal.empty }
        specify { subject.element_def == tm }
      end
    end

    context "CompositeElementDef" do
      pending
    end
  end

  describe "#reader" do
    let(:isa) { Stupidedi::Interchange::FiveOhOne::InterchangeHeader }

    context "CompositeElementDef" do
      let(:req) { Stupidedi::FiftyTen::Base::Designations::ElementRequirement }

      def composite_def(*element_defs)
        Stupidedi::FiftyTen::Base::CompositeElementDef.new("XX", "Name", "Purpose", *element_defs.map{|e| e.component_use(req::M) })
      end

      def composite_val(cdef, *component_vals)
        Stupidedi::Values::CompositeElementVal.new(cdef, component_vals)
      end

      context "defined with a single component element" do
        it "parses empty" do
          composite_def(dt).reader("~...", isa.default).read.map do |result|
            result.value.should be_empty
            result.value.component_element_vals.length.should == 1
            result.value[0].should == values::DateVal.empty
            result.remainder.input.should == "~..."
          end.should be_defined
        end

        it "parses empty", :random => true do
          # Note we cannot lookup these methods from within property { ... }, but
          # accessing local variables declared outside the closure (like so) does work.
          component_defs = [n0, n1, n2, n3, n4, n5, n6, n7, n8, n9, r, id, an, dt, tm]

          property do
            # Create an interchange header with random delimiters
            with(document.delimiters) do
              # Choose a random simple element definition
              ce = choose(component_defs)

              # Choose a random delimiter from the definition of isa, generated above
              delim = char.delimiter
              guard delim != component_separator

              # Generate a sequence of spaces ' ' of random length, and then insert
              # control characters into it at random positions
              space = stream.agitate(stream.space(between(0, 16)))

              # Pass this value to the block given to check below
              [space, delim, stream.string, ce, current.isa]
            end
          end.check do |space, delim, rest, ce, isa|
            # Convert the simple element definition into a one-element composite element definition
            composite_def(ce).reader("#{space}#{delim}#{rest}", isa).read.map do |result|
              # The result.value is a CompositeElementVal
              result.value.should be_empty

              # Only a single component was parsed
              result.value.component_element_vals.length.should == 1

              # The delimiter and anything after it was not parsed
              result.remainder.input.should == "#{delim}#{rest}"
            end.should be_defined
          end
        end

        # TODO this is error handling
        it "parses no more than the defined number of elements" do
          result = composite_def(dt).reader("20001231:0030:XYZ...", isa.default).read
          result.should_not be_defined
          result.explanation.should == %[Found a component separator ":" instead of an element separator, segment terminator, or repetition separator]
        end

        it "parses non-empty input"

        it "parses non-empty input", :random => true do
          component_defs = [n0, n1, n2, n3, n4, n5, n6, n7, n8, n9, r, id, an, dt, tm]

          property do
            with(document.delimiters) do
              ce    = choose(component_defs)
              delim = char.delimiter
              guard delim != component_separator

              [stream.pad(stream.agitate(element(ce))), delim, stream.string, ce, current.isa]
            end
          end.check do |data, delim, rest, ce, isa|
            cdef = composite_def(ce)
            cdef.reader("#{data}#{delim}#{rest}", isa).read.tap do |result|
              # Check that parsing the string with SimpleElementDef produces the same value
              #   (note we're comparing Either to Either in this block (unlike map below))
              result.should == ce.reader("#{data}#{delim}#{rest}", isa).read.map{|x| x.map{|y| composite_val(cdef, y) }}
            end.map do |result|
              result.value.component_element_vals.length.should == 1

              # Note that even if the delimiter is the component separator, the reader does not
              # consume it. That means at this point, we know the number of component elements
              # and promise to read no more than that number of elements from the input stream.
              result.remainder.input.should == "#{delim}#{rest}"
            end.should be_defined
          end
        end
      end

      context "defined with more than one component element" do
        it "parses empty" do
          dictionary::C023.reader("*...", isa.default).read.map do |result|
            result.value.should be_empty
            result.value.element_def.should == dictionary::C023
            result.value.component_element_vals.length.should == 3

            result.value[0].should be_empty
            result.value[1].should be_empty
            result.value[2].should be_empty

            result.value[0].should == values::StringVal.empty
            result.value[1].should == values::IdentifierVal.empty
            result.value[2].should == values::IdentifierVal.empty

            result.remainder.input.should == "*..."
          end.should be_defined
        end

        it "parses empty", :random => true do
          component_defs = [n0, n1, n2, n3, n4, n5, n6, n7, n8, n9, r, id, an, dt, tm]

          property do
            with(document.delimiters) do
              with(:size, between(2, 8)) do
                delim  = char.delimiter
                guard delim != component_separator

                cs     = array { choose(component_defs) }
                blanks = array { stream.agitate(stream.space(between(0, 16))) }

                [blanks, delim, stream.string, cs, current.isa]
              end
            end
          end.check do |blanks, delim, rest, cs, isa|
            composite_def(*cs).reader("#{blanks.join(isa.component_separator)}#{delim}#{rest}", isa).read.map do |result|
              result.value.should be_empty
              result.value.component_element_vals.length.should == cs.length
              result.remainder.input.should == "#{delim}#{rest}"
            end.should be_defined
          end
        end

        # TODO this is error handling
        it "parses no more than the defined number of elements" do
          result = composite_def(dt, tm).reader("20001231:0030:XYZ...", isa.default).read
          result.should_not be_defined
        end

        it "parses input with first few elements not present" do
          dictionary::C023.reader("::8*...", isa.default).read.map do |result|
            result.value.should_not be_empty
            result.value.element_def.should == dictionary::C023
            result.value[0].should be_empty
            result.value[1].should be_empty
            result.value[2].should == "8"
            result.remainder.input.should == "*..."
          end.should be_defined
        end

        it "parses input with first few elements not present", :random => true do
          component_defs = [n0, n1, n2, n3, n4, n5, n6, n7, n8, n9, r, id, an, dt, tm]

          property do
            with(document.delimiters) do
              with(:size, between(2, 16)) do
                delim  = char.delimiter
                guard delim != component_separator

                cs     = array { choose(component_defs) }
                blanks = with(:size, between(1, cs.length - 1)) { array { stream.agitate(stream.space(between(0, 16))) }}
                values = cs.last(size - blanks.length).map {|c| stream.agitate(element(c)) }

                [blanks, values, delim, stream.string, cs, current.isa]
              end
            end
          end.check do |blanks, values, delim, rest, cs, isa|
            input = "#{(blanks + values).join(isa.component_separator)}#{delim}#{rest}"

            composite_def(*cs).reader(input, isa).read.map do |result|
              result.value.should_not be_empty
              result.value.component_element_vals.length.should == cs.length
              result.remainder.input.should == "#{delim}#{rest}"

              # The first few components should be blank
              result.value.component_element_vals.take(blanks.length).all?(&:empty?).should be_true

              # The remaining components should not be blank
              result.value.component_element_vals.drop(blanks.length).any?(&:empty?).should be_false
            end.should be_defined
          end
        end

        it "parses input with middle elements not present" do
          dictionary::C023.reader("11::8*...", isa.default).read.map do |result|
            result.value.should_not be_empty
            result.value.element_def.should == dictionary::C023
            result.value[0].should == "11"
            result.value[1].should be_empty
            result.value[2].should == "8"
            result.remainder.input.should == "*..."
          end.should be_defined
        end

        it "parses input with middle elements not present", :random => true do
          component_defs = [n0, n1, n2, n3, n4, n5, n6, n7, n8, n9, r, id, an, dt, tm]

          property do
            with(document.delimiters) do
              with(:size, between(3, 16)) do
                delim  = char.delimiter
                guard delim != component_separator

                cs     = array { choose(component_defs) }
                head   = cs.take(between(1, cs.length - 2)).map{|c| stream.agitate(element(c)) }
                blanks = map(between(1, cs.length - head.length - 1)) { stream.agitate(stream.space(between(0, 16))) }
                tail   = cs.drop(head.length + blanks.length).map{|c| stream.agitate(element(c)) }

                [head, blanks, tail, delim, stream.string, cs, current.isa]
              end
            end
          end.check do |head, blanks, tail, delim, rest, cs, isa|
            input = [head, blanks, tail].map{|x| x.join(isa.component_separator) }.join(isa.component_separator) << delim << rest

            composite_def(*cs).reader(input, isa).read.map do |result|
              result.value.should_not be_empty
              result.value.component_element_vals.length.should == cs.length
              result.remainder.input.should == "#{delim}#{rest}"

              # The first few components should be blank
              result.value.component_element_vals.take(head.length).any?(&:empty?).should be_false

              # The remaining components should not be blank
              result.value.component_element_vals.slice(head.length, blanks.length).all?(&:empty?).should be_true

              # The remaining components should not be blank
              result.value.component_element_vals.drop(head.length + blanks.length).any?(&:empty?).should be_false
            end.should be_defined
          end
        end

        it "parses input with last few elements not present (whitespace)" do
          dictionary::C023.reader("11:  :  *...", isa.default).read.map do |result|
            result.value.should_not be_empty
            result.value.element_def.should == dictionary::C023
            result.value[0].should == "11"
            result.value[1].should be_empty
            result.value[2].should be_empty
            result.remainder.input.should == "*..."
          end.should be_defined
        end

        it "parses input with last few elements not present (whitespace)", :random => true do
          component_defs = [n0, n1, n2, n3, n4, n5, n6, n7, n8, n9, r, id, an, dt, tm]

          property do
            with(document.delimiters) do
              with(:size, between(3, 16)) do
                delim  = char.delimiter
                guard delim != component_separator

                cs     = array { choose(component_defs) }
                values = cs.take(between(1, cs.length - 1)).map{|c| stream.agitate(element(c)) }
                blanks = map(size - values.length) { stream.agitate(stream.space(between(0, 16))) }

                [values, blanks, delim, stream.string, cs, current.isa]
              end
            end
          end.check do |values, blanks, delim, rest, cs, isa|
            input = "#{(values + blanks).join(isa.component_separator)}#{delim}#{rest}"

            composite_def(*cs).reader(input, isa).read.map do |result|
              result.value.should_not be_empty
              result.value.component_element_vals.length.should == cs.length
              result.remainder.input.should == "#{delim}#{rest}"

              # The first few components should be blank
              result.value.component_element_vals.take(values.length).any?(&:empty?).should be_false

              # The remaining components should not be blank
              result.value.component_element_vals.drop(values.length).all?(&:empty?).should be_true
            end.should be_defined
          end
        end

        it "parses input with last few elements not present (delimiters)" do
          dictionary::C023.reader("11::*...", isa.default).read.map do |result|
            result.value.should_not be_empty
            result.value.element_def.should == dictionary::C023
            result.value[0].should == "11"
            result.value[1].should be_empty
            result.value[2].should be_empty
            result.remainder.input.should == "*..."
          end.should be_defined
        end

        it "parses input with last few elements not present (delimiters)", :random => true do
          component_defs = [n0, n1, n2, n3, n4, n5, n6, n7, n8, n9, r, id, an, dt, tm]

          property do
            with(document.delimiters) do
              with(:size, between(3, 16)) do
                delim   = char.delimiter
                guard delim != component_separator

                cs      = array { choose(component_defs) }
                values  = cs.take(between(1, cs.length - 1)).map{|c| stream.agitate(element(c)) }
                nblanks = size - values.length

                [values, nblanks, delim, stream.string, cs, current.isa]
              end
            end
          end.check do |values, nblanks, delim, rest, cs, isa|
            input = "#{(values + ([''] * nblanks)).join(isa.component_separator)}#{delim}#{rest}"

            composite_def(*cs).reader(input, isa).read.map do |result|
              result.value.should_not be_empty
              result.value.component_element_vals.length.should == cs.length
              result.remainder.input.should == "#{delim}#{rest}"

              # The first few components should be blank
              result.value.component_element_vals.take(values.length).any?(&:empty?).should be_false

              # The remaining components should not be blank
              result.value.component_element_vals.drop(values.length).all?(&:empty?).should be_true
            end.should be_defined
          end
        end

        it "parses input with last few elements not present (truncated)" do
          dictionary::C023.reader("11*...", isa.default).read.map do |result|
            result.value.should_not be_empty
            result.value.element_def.should == dictionary::C023
            result.value[0].should == "11"
            result.value[1].should be_empty
            result.value[2].should be_empty
            result.remainder.input.should == "*..."
          end.should be_defined
        end

        it "parses input with last few elements not present (truncated)", :random => true do
          component_defs = [n0, n1, n2, n3, n4, n5, n6, n7, n8, n9, r, id, an, dt, tm]

          property do
            with(document.delimiters) do
              with(:size, between(3, 16)) do
                delim = char.delimiter
                guard delim != component_separator

                cs     = array { choose(component_defs) }
                values = cs.take(between(1, cs.length - 1)).map{|c| stream.agitate(element(c)) }

                [values, delim, stream.string, cs, current.isa]
              end
            end
          end.check do |values, delim, rest, cs, isa|
            input = "#{values.join(isa.component_separator)}#{delim}#{rest}"

            composite_def(*cs).reader(input, isa).read.map do |result|
              result.value.should_not be_empty
              result.value.component_element_vals.length.should == cs.length
              result.remainder.input.should == "#{delim}#{rest}"

              # The first few components should be blank
              result.value.component_element_vals.take(values.length).any?(&:empty?).should be_false

              # The remaining components should not be blank
              result.value.component_element_vals.drop(values.length).all?(&:empty?).should be_true
            end.should be_defined
          end
        end

        it "parses input with all elements present" do
          dictionary::C023.reader("11:B:8*...", isa.default).read.map do |result|
            result.value.should_not be_empty
            result.value.element_def.should == dictionary::C023
            result.value[0].should == "11"
            result.value[1].should == "B"
            result.value[2].should == "8"
            result.remainder.input.should == "*..."
          end.should be_defined
        end

        it "parses input with all elements present", :random => true do
          component_defs = [n0, n1, n2, n3, n4, n5, n6, n7, n8, n9, r, id, an, dt, tm]

          property do
            with(document.delimiters) do
              with(:size, between(3, 16)) do
                delim  = char.delimiter
                guard delim != component_separator

                cs     = array { choose(component_defs) }
                values = cs.map{|c| stream.agitate(element(c)) }

                [values, delim, stream.string, cs, current.isa]
              end
            end
          end.check do |values, delim, rest, cs, isa|
            input = "#{values.join(isa.component_separator)}#{delim}#{rest}"

            composite_def(*cs).reader(input, isa).read.map do |result|
              result.value.should_not be_empty
              result.value.component_element_vals.length.should == cs.length
              result.remainder.input.should == "#{delim}#{rest}"

              # None of the components should be blank
              result.value.component_element_vals.any?(&:empty?).should be_false
            end.should be_defined
          end
        end

      end
    end
  end

  describe "#writer" do
    context "SimpleElementDef" do
      pending
    end

    context "CompositeElementDef" do
      pending
    end
  end

end
