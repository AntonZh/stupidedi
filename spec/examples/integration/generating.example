require "spec_helper"

describe "Generating" do
  include NavigationMatchers

  let(:config) do
    Stupidedi::Config.new.customize do |config|
      config.interchange.customize do |c|
        c.register("00401") { Stupidedi::Versions::Interchanges::FourOhOne::InterchangeDef }
        c.register("00501") { Stupidedi::Versions::Interchanges::FiveOhOne::InterchangeDef }
      end

      config.functional_group.customize do |c|
        c.register("004010") { Stupidedi::Versions::FunctionalGroups::FortyTen::FunctionalGroupDef }
        c.register("005010") { Stupidedi::Versions::FunctionalGroups::FiftyTen::FunctionalGroupDef }
      end

      config.transaction_set.customize do |c|
        c.register("005010", "HN", "277") { Stupidedi::Versions::FunctionalGroups::FiftyTen::TransactionSetDefs::HN277 }
        c.register("005010", "HP", "835") { Stupidedi::Versions::FunctionalGroups::FiftyTen::TransactionSetDefs::HP835 }
        c.register("005010", "HC", "837") { Stupidedi::Versions::FunctionalGroups::FiftyTen::TransactionSetDefs::HC837 }
        c.register("005010", "FA", "999") { Stupidedi::Versions::FunctionalGroups::FiftyTen::TransactionSetDefs::FA999 }

        c.register("005010X214", "HN", "277", Stupidedi::Guides::FiftyTen::X214::HN277)
        c.register("005010X221", "HP", "835", Stupidedi::Guides::FiftyTen::X221::HP835)  # A1
        c.register("005010X222", "HC", "837", Stupidedi::Guides::FiftyTen::X222::HC837P) # A1
        c.register("005010X231", "FA", "999", Stupidedi::Guides::FiftyTen::X231::FA999)  # A1
      end
    end
  end

  let(:strict)  { Stupidedi::Builder::BuilderDsl.build(config, true)  }
  let(:lazy)    { Stupidedi::Builder::BuilderDsl.build(config, false) }

  context "unrecognized methods" do
    it "raises an exception" do
      lambda { lazy.xyz }.should \
        raise_error(NoMethodError)
    end
  end

  context "unrecognized interchange version" do
    def isa(dsl, version)
      dsl.ISA("00", "",
              "00", "",
              "ZZ", "",
              "ZZ", "",
              Time.now.utc,
              Time.now.utc,
              "", version, 123456789, "1", "T", "")
    end

    context "when strict" do
      it "quietly proceeds" do
        # 0050x isn't configured
        isa(lazy, "0050x")

        # An invalid ISA segment was added
        lazy.zipper.select{|z| z.node.invalid? }.should be_defined

        # It's parent is an InvalidEnvelopeVal
        lazy.zipper.select{|z| z.parent.node.invalid? }.should be_defined
      end
    end

    context "when non-strict" do
      it "loudly complains" do
        lambda do
          isa(strict, "0050x")
        end.should raise_error('unknown interchange version "0050x"')

        # The ISA segment wasn't added
        lazy.should be_empty
      end
    end
  end

  context "interchange 00501" do
    context "tracks separators" do
      def isa(dsl, component = ":", repetition = "^")
        dsl.ISA("00", "",
                "00", "",
                "ZZ", "431777999",
                "ZZ", "133052274",
                Time.now.utc,
                Time.now.utc,
                repetition, "00501", 123456789, "1", "T",
                component)
      end

      it "on the first interchange" do
        isa(lazy, ":", "^")

        lazy.machine.separators.component.should == ":"
        lazy.machine.separators.repetition.should == "^"
      end

      it "on subsequent interchanges" do
        isa(lazy, "$", "%")
        isa(lazy, "@", "#")

        lazy.machine.separators.component.should == "@"
        lazy.machine.separators.repetition.should == "#"

        lazy.machine.prev.tap do |machine|
          machine.separators.component.should == "$"
          machine.separators.repetition.should == "%"
        end.should be_defined
      end
    end

    context "with missing IEA" do
      def isa(dsl)
        dsl.ISA("00", "",
                "00", "",
                "ZZ", "431777999",
                "ZZ", "133052274",
                Time.now.utc,
                Time.now.utc,
                "", "00501", 123456789, "1", "T", "")
      end

      context "when strict" do
        it "loudly complains" do
          isa(strict)
          lambda { isa(strict) }.should \
            raise_error("required segment IEA is missing from interchange 00501")

          strict.should be_first
        end
      end

      context "when non-strict" do
        it "quietly proceeds" do
          isa(lazy)
          lambda { isa(lazy) }.should_not \
            raise_error("required segment IEA is missing from interchange 00501")

          lazy.should_not be_first
        end
      end
    end

    context "with mising required elements" do
      def isa(dsl)
        dsl.ISA("00", "",
                "00", "",
                "ZZ", "",
                "ZZ", "133052274",
                Time.now.utc,
                Time.now.utc,
                "", "00501", 123456789, "1", "T", "")
      end

      context "when strict" do
        it "loudly complains" do
          lambda { isa(strict) }.should \
            raise_error("required element ISA-06 is blank")

          strict.should be_empty
        end
      end

      context "when non-strict" do
        it "quietly proceeds" do
          lambda { isa(lazy) }.should_not \
            raise_error("required element ISA-06 is blank")

          lazy.element(6).select{|e| e.node.empty? }.should be_defined
        end
      end
    end

    context "with invalid ID values" do
      def isa(dsl)
        dsl.ISA("XX", "",
                "00", "",
                "ZZ", "431777999",
                "ZZ", "133052274",
                Time.now.utc,
                Time.now.utc,
                "", "00501", 123456789, "1", "T", "")
      end

      context "when strict" do
        it "loudly complains" do
          lambda { isa(strict) }.should \
            raise_error("value XX not allowed in element ISA-01")

          strict.should be_empty
        end
      end

      context "when non-strict" do
        it "quietly proceeds" do
          lambda { isa(lazy) }.should_not \
            raise_error("value XX not allowed in element ISA-01")

          lazy.element(1).select{|e| e.node == "XX" }.should be_defined
        end
      end
    end

    context "with invalid DT values" do
      def isa(dsl)
        dsl.ISA("00", "",
                "00", "",
                "ZZ", "431777999",
                "ZZ", "133052274",
                "DATE",
                Time.now.utc,
                "", "00501", 123456789, "1", "T", "")
      end

      context "when strict" do
        it "loudly complains" do
          lambda { isa(strict) }.should \
            raise_error("invalid element ISA-09")

          strict.should be_empty
        end
      end

      context "when non-strict" do
        it "quietly proceeds" do
          lambda { isa(lazy) }.should_not \
            raise_error("invalid element ISA-09")

          lazy.element(9).select{|e| e.node.invalid? }.should be_defined
        end
      end
    end

    context "with invalid TM values" do
      def isa(dsl)
        dsl.ISA("00", "",
                "00", "",
                "ZZ", "431777999",
                "ZZ", "133052274",
                Time.now.utc,
                "TIME",
                "", "00501", 123456789, "1", "T", "")
      end

      context "when strict" do
        it "loudly complains" do
          lambda { isa(strict) }.should \
            raise_error("invalid element ISA-10")

          strict.should be_empty
        end
      end

      context "when non-strict" do
        it "quietly proceeds" do
          lambda { isa(lazy) }.should_not \
            raise_error("invalid element ISA-10")

          lazy.element(10).select{|e| e.node.invalid? }.should be_defined
        end
      end
    end

    context "incorrect element lengths" do

      context "with Nn elements that are too long" do
      end

      context "with Nn element that are too short" do
      end

      context "with R elements that are too long" do
      end

      context "with R elements that are too short" do
      end

      context "with AN elements that are too long" do
      end

      context "with AN elements that are too short" do
      end

      context "with TM elements that are too long" do
      end

      context "with TM elements that are too short" do
      end

      context "with DT elements that are too long" do
      end

      context "with DT elements that are too short" do
      end

    end

    context "placeholder elements" do
      def setup(dsl, ts)
        dsl.ISA("00", "",
                "00", "",
                "ZZ", "431777999",
                "ZZ", "133052274",
                Time.now.utc,
                Time.now.utc,
                "^", "00501", 123456789, "1", "T", ":")

        dsl.GS("HC",
               "SENDER ID",
               "RECEIVER ID",
               Time.now.utc,
               Time.now.utc, "1", "X", ts)
      end

      context "with default element placeholder" do
        context "when value cannot be inferred" do
          it "raises an error" do
            setup(lazy, "005010X222")

            lambda { lazy.ST("837", lazy.default, "005010X222") }.should \
              raise_error("ST02 cannot be inferred")
          end
        end

        context "when blank value can be inferred" do
          it "generates an empty element" do
            setup(lazy, "005010X221")

            lazy.ST("835", "CONTROLNUM", lazy.default)
            lazy.element(3).select{|e| e.node.blank? }.should be_defined
          end
        end

        context "when non-empty value can be inferred" do
          it "generates a non-empty element value" do
            setup(lazy, "005010X222")

            lazy.ST("837", "CONTROLNUM", lazy.default)
            lazy.element(3).select{|e| e.node == "005010X222" }.should be_defined
          end
        end
      end

      context "with not_used element placeholder" do
        context "when element is declared forbidden" do
          it "generates an empty element" do
            setup(lazy, "005010X221")

            lazy.ST("835", "CONTROLNUM", lazy.not_used)
            lazy.element(3).select{|e| e.node.blank? }.should be_defined
          end
        end

        context "when element is not declared forbidden" do
          it "generates a non-empty element value" do
            setup(lazy, "005010X222")

            lambda { lazy.ST("837", "CONTROLNUM", lazy.not_used) }.should \
              raise_error("ST03 is not forbidden")
          end
        end
      end

    end
  end

  context "interchange 00401" do
  end
end
